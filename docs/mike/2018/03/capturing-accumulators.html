<!DOCTYPE HTML><html xmlns="http://www.w3.org/1999/xhtml">
   <head><meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      
      <title>Capturing Accumulators</title>
      <meta name="id" content="223">
      <meta name="author" content="Michael Kay">
      <meta name="pubdate" content="2018-03-28T08:09:03">
      <meta name="basename" content="capturing_accumulators">
      <meta name="blog-id" content="3">
   <link rel="stylesheet" type="text/css" href="/css/blog.css"><link rel="stylesheet" type="text/css" href="/css/michael-kay.css"><meta content="Saxon diaries" property="og:site_name"><meta content="https://blog.saxonica.com/img/sitecard.png" property="og:image"><meta content="Michael Kay's blog." property="og:description"><meta content="https://blog.saxonica.com/mike/" property="og:url"><meta content="600" property="og:image:width"><meta content="315" property="og:image:height"><meta content="Capturing Accumulators" property="og:title"><meta content="en_GB" property="og:locale"><meta content="website" property="og:type"><meta name="viewport" content="width=device-width, initial-scale=1.0"></head>
   <body class="michael-kay"><header><div class="banner"><h1><a href="/mike/">Saxon diaries</a></h1><div class="tagline">Michael Kay’s blog</div></div><h2>Capturing Accumulators</h2><aside class="nav"><div class="navlinks"><div id="search"><form action="https://www.google.com/search" target="_parent"><span>Search: </span><input size="20" name="as_q"><input type="hidden" name="hl" value="en"><input type="hidden" name="ie" value="UTF-8"><input type="hidden" name="btnG" value="Google+Search"><input type="hidden" name="as_qdr" value="all"><input type="hidden" name="as_occt" value="any"><input type="hidden" name="as_dt" value="i"><input type="hidden" name="as_sitesearch" value="blog.saxonica.com"></form></div><div id="blogroll"><a href="/">Home (combined archives)</a><br><a href="/announcements/">Announcements</a><br><a href="/mike/">Saxon diaries</a><br><a href="/oneil/">O’Neil Delpratt’s Blog</a><br><a href="/norm/">Saxon Chronicles</a></div></div></aside><div class="byline"><span class="by">By </span><span class="name"><a href="/authors.html#michael-kay">Michael Kay</a></span><span class="on"> on </span><a href="/authors.html#michael-kay-D2018-03"><span class="date" time="2018-03-28T08:09:03">March&nbsp;28, 2018 at 08:09a.m.</span></a></div></header><main>
      
      <p>A <a href="https://stackoverflow.com/questions/48983320/conditional-streaming-accumulator-in-xslt-3/48985112">recent post on StackOverflow</a> made me realise that streaming accumulators in XSLT 3.0 are much harder to use than
         they need to be.
         </p>
      <p>
         
         
         A reminder about what accumulators do. The idea is that as you stream your way through
         a large document, you can have a number of tasks running in the background (called
         accumulators) which observe the document as it goes past, and accumulate information
         which is then available to the "main" line of processing in the foreground. For example,
         you might have an accumulator that simply keeps a note of the most recent section
         heading in a document; that's useful because the foreground processing can't simply
         navigate around the document to find the current section heading when it finds that
         it's needed.
         </p>
      <p>
         Accumulator rules can fire either on start tags or end tags or both, or they can be
         associated with text nodes or attributes. But there's a severe limitation: a streaming
         accumulator must be motionless: that's XSLT 3.0 streaming jargon to say that it can
         only see what's on the parser's stack at the time the accumulator triggers. This affects
         both the pattern that controls when the accumulator is triggered, and the action that
         it can take when the rule fires.
         </p>
      <p>
         
         
         For example, you can't fire a rule with the pattern <code>match="section[title='introduction']"</code> because navigation to child elements (title) is not allowed in a motionless pattern.
         Similarly, if the rule fires on &nbsp;<code style="font-size: 13px;">match="section"</code>, then you can't access the title in the rule action (<code>select="title"</code>) because the action too must be motionless. In some cases a workaround is to have
         an accumulator that matches the text nodes (<code>match="section/title/text()[.='introduction']"</code>) but that doesn't work if section titles can have mixed content.
         </p>
      <p>
         
         
         It turns out there's a simple fix, which I call a <i>capturing accumulator rule</i>. A capturing accumulator rule is indicated by the extension attribute <code>&lt;xsl:accumulator-rule saxon:capture="yes" phase="end"&gt;</code>, which will always be a rule that fires on an end-element tag. For a capturing rule,
         the background process listens to all the parser events that occur between the start
         tag and the end tag, and uses these to build a snapshot copy of the node. A snapshot
         copy is like the result of the fn:snapshot function - it's a deep copy of the matched
         node, with ancestor elements and their attributes tagged on for good measure. This
         snapshot copy is then available to the action part of the rule processing the end
         tag. The match patterns that trigger the accumulator rule still need to be motionless,
         but the action part now has access to a complete copy of the element (plus its ancestor
         elements and their attributes).
         </p>
      <p>
         Here's an example. Suppose you've got a large document like the XSLT specification,
         and you want to produce a sorted glossary at the end, and you want to do it all in
         streamed mode. Scattered throughout the document are term definitions like this:
         </p>
      <pre>&lt;termdef id="dt-stylesheet" term="stylesheet"&gt;A&nbsp;&nbsp;&lt;term&gt;stylesheet&lt;/term&gt; consists of one or more packages: specifically, one
&nbsp; &nbsp;&lt;termref def="dt-top-level-package"&gt;top-level package&lt;/termref&gt; and zero or
&nbsp; &nbsp;more &lt;termref def="dt-library-package"&gt;library packages&lt;/termref&gt;.&lt;/termdef&gt;</pre>
      <p>
         
         Now we can write an accumulator which simply accumulates these term definitions as
         they are encountered:
         
         
         </p>
      <pre>&lt;xsl:accumulator name="terms" streamable="yes"&gt;
&nbsp; &nbsp; &lt;xsl:accumulator-rule match="termdef" phase="end" select="($value, .)" saxon:capture="yes"/&gt;
&lt;/xsl:accumulator&gt;</pre>
      <p>
         (the <code>select</code> expression here takes the existing value of the accumulator, <code>$value</code>, and appends the snapshot of the current termdef element, which is available as the
         context item ".")
         </p>
      <p>
         And now, at the end of the processing, we can output the glossary like this:
         
         </p>
      <pre>&lt;xsl:template match="/" mode="streamable-mode"&gt;
&nbsp; &nbsp; &lt;html&gt;&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &lt;!-- main foreground processing goes here --&gt;
&nbsp; &nbsp; &nbsp; &nbsp; &lt;xsl:apply-templates mode="#current"/&gt;
&nbsp; &nbsp; &nbsp; &nbsp; &lt;!-- now output the glossary --&gt;
&nbsp; &nbsp; &nbsp; &nbsp; &lt;div id="glossary" class="glossary"&gt;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;xsl:apply-templates select="accumulator-after('terms')" mode="glossary"&gt;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;xsl:sort select="@term" lang="en"/&gt;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;/xsl:apply-templates&gt;
&nbsp; &nbsp; &nbsp; &nbsp; &lt;/div&gt;
&nbsp; &nbsp; &lt;/html&gt;
&lt;/xsl:template&gt;</pre>
      <p>
         The value of the accumulator is a list of snapshots of termdef elements, and because
         these are snapshots, the processing at this point does not need to be streamable (snapshots
         are ordinary trees held in memory).
         </p>
      <p>
         The amount of memory needed to accomplish this is whatever is needed to hold the glossary
         entries. This follows the design principle behind XSLT 3.0 streaming, which was not
         to do just those things that required zero working memory, but to enable the programmer
         to do things that weren't purely streamable, while having control over the amount
         of memory needed.
         </p>
      <p>
         I think it's hard to find an easy way to tackle this particular problem without the
         new feature of capturing accumulator rules, so I hope it will prove a useful extension.
         </p>
      <p>
         I've implemented this for Saxon 9.9. Interestingly, it only took about 25 lines of
         code: half a dozen to enable the new extension attribute, half a dozen to allow it
         to be exported to SEF files and re-imported, two or three to change the streamability
         analysis, and a few more to invoke the existing streaming implementation of the snapshot
         function from the accumulator watch code. Testing and documenting the feature was
         a lot more work than implementing it.
         </p>
      <p>
         Here's a complete stylesheet that fleshes out the creation of a (skeletal) glossary:
         </p>
      <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:package
&nbsp; name="http://www.w3.org/xslt30-test/accumulator/capture-203"
&nbsp; package-version="1.0"
&nbsp; declared-modes="no"
&nbsp; xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
&nbsp; xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:f="http://accum001/"
&nbsp; xmlns:saxon="http://saxon.sf.net/"
&nbsp; exclude-result-prefixes="#all" version="3.0"&gt;

&nbsp; &lt;!-- Stylesheet to produce a glossary using capturing accumulators --&gt;
&nbsp; 
&nbsp; &lt;!-- The source document is a W3C specification in xmlspec format, containing
&nbsp; &nbsp; term definitions in the form &lt;termdef term="banana"&gt;A soft &lt;termref def="fruit"/&gt;&lt;/termdef&gt; --&gt;
&nbsp; 
&nbsp; &lt;!-- This test case shows the essential principles of how to render such a document
&nbsp; &nbsp; in streaming mode, with an alphabetical glossary of defined terms at the end --&gt;
&nbsp; 
&nbsp; &lt;xsl:param name="streamable" static="yes" select="'yes'"/&gt;
&nbsp; 
&nbsp; &lt;xsl:accumulator name="glossary" as="element(termdef)*" initial-value="()" streamable="yes"&gt;
&nbsp; &nbsp; &lt;xsl:accumulator-rule match="termdef" phase="end" saxon:capture="yes" select="($value, .)"/&gt;
&nbsp; &lt;/xsl:accumulator&gt;

&nbsp; &lt;xsl:mode streamable="yes" on-no-match="shallow-skip" use-accumulators="glossary"/&gt;
&nbsp; 
&nbsp; &lt;xsl:template name="main"&gt;
&nbsp; &nbsp; &lt;xsl:source-document href="xslt.xml" streamable="yes" use-accumulators="glossary"&gt;
&nbsp; &nbsp; &nbsp; &lt;xsl:apply-templates select="."/&gt;
&nbsp; &nbsp; &lt;/xsl:source-document&gt;
&nbsp; &lt;/xsl:template&gt;
&nbsp; 
&nbsp;&lt;xsl:template match="/"&gt;
&nbsp; &nbsp; &lt;out&gt;
&nbsp; &nbsp; &nbsp; &lt;!-- First render the body of the document --&gt;
&nbsp; &nbsp; &nbsp; &lt;xsl:apply-templates/&gt;
&nbsp; &nbsp; &nbsp; &lt;!-- Now generate the glossary --&gt;
&nbsp; &nbsp; &nbsp; &lt;table&gt;
&nbsp; &nbsp; &nbsp; &nbsp; &lt;tbody&gt;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;xsl:apply-templates select="accumulator-after('glossary')" mode="glossary"&gt;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;xsl:sort select="@term" lang="en"/&gt;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;/xsl:apply-templates&gt;
&nbsp; &nbsp; &nbsp; &nbsp; &lt;/tbody&gt;
&nbsp; &nbsp; &nbsp; &lt;/table&gt;
&nbsp; &nbsp; &lt;/out&gt;
&nbsp; &lt;/xsl:template&gt;
&nbsp; 
&nbsp; &lt;xsl:template match="div1|inform-div1"&gt;
&nbsp; &nbsp; &lt;div id="{@id}"&gt;
&nbsp; &nbsp; &nbsp; &lt;xsl:apply-templates/&gt;
&nbsp; &nbsp; &lt;/div&gt;
&nbsp; &lt;/xsl:template&gt;
&nbsp; 
&nbsp; &lt;!-- Main document processing: just output the headings --&gt;
&nbsp; 
&nbsp; &lt;xsl:template match="div1/head | inform-div1/head"&gt;
&nbsp; &nbsp; &lt;xsl:attribute name="title" select="."/&gt;
&nbsp; &lt;/xsl:template&gt;
&nbsp; 
&nbsp; &lt;!-- Glossary processing --&gt;
&nbsp; 
&nbsp; &lt;xsl:mode name="glossary" streamable="no"/&gt;
&nbsp; 
&nbsp; &lt;xsl:template match="termdef" mode="glossary"&gt;
&nbsp; &nbsp; &lt;tr&gt;
&nbsp; &nbsp; &nbsp; &lt;td&gt;
&nbsp; &nbsp; &nbsp; &nbsp; &lt;xsl:value-of select="@term"/&gt;
&nbsp; &nbsp; &nbsp; &lt;/td&gt;
&nbsp; &nbsp; &nbsp; &lt;td&gt;
&nbsp; &nbsp; &nbsp; &nbsp; &lt;xsl:value-of select="."/&gt;
&nbsp; &nbsp; &nbsp; &lt;/td&gt;
&nbsp; &nbsp; &lt;/tr&gt;
&nbsp; &lt;/xsl:template&gt;

&lt;/xsl:package&gt;</pre>
   </main><footer><div class="prev-uri"><a href="/mike/2018/03/diagnostics-on-type-errors.html">Diagnostics on Type Errors</a></div><div class="next-uri"><a href="/mike/2018/04/navigating-xml-trees-using-java-streams.html">Navigating XML trees using Java Streams</a></div></footer></body>
</html>