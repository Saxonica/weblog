<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" xml:lang="EN-us"><title>Saxonica Weblogs</title><link href="https://blog.saxonica.com/" rel="alternate" type="text/html"/><link href="https://blog.saxonica.com/atom.xml" rel="self"/><id>https://blog.saxonica.com/atom.xml</id><updated>2023-03-17T10:57:13.971624Z</updated><entry><title>Brand new weblog, just like the old weblog</title><link href="https://blog.saxonica.com/norm/2023/03/16-weblog.html" rel="alternate" type="text/html"/><id>https://blog.saxonica.com/norm/2023/03/16-weblog.html</id><published>2023-03-16T10:30:00Z</published><content type="xhtml" xml:base="https://blog.saxonica.com/norm/2023/03/16-weblog.html"><div xmlns="http://www.w3.org/1999/xhtml">


<p>As part of some infrastructure cleanup, we decided to change how
the weblog is managed. It’s now hosted on
<a href="https://blog.saxonica.com/">blog.saxonica.com</a>.</p>

<p>All of the old posts have been copied over and redirects are in
place. Along the way, I cleaned up a few broken links.</p>

<p>If anything seems broken, please do let me know!</p>

</div></content></entry><entry><title>SaxonC HE “11.99” pre-release</title><link href="https://blog.saxonica.com/norm/2022/12/23-saxon-c.html" rel="alternate" type="text/html"/><id>https://blog.saxonica.com/norm/2022/12/23-saxon-c.html</id><published>2022-12-23T17:15:00Z</published><content type="xhtml" xml:base="https://blog.saxonica.com/norm/2022/12/23-saxon-c.html"><div xmlns="http://www.w3.org/1999/xhtml">


<p>Happy holidays everyone! Wishing you peace and joy in this festive season!</p>

<p>And toys.</p>

<p>Since we didn't get any releases out before Christmas, we've
packaged up a special treat for anyone who wants to play with
something new: SaxonC HE 12.0 in Python.</p>

<p>We've built and deployed the Python "wheels" for installing SaxonC
HE “11.99” (that's the 12.0 code base, but it's a test release so I
didn't want to use up one of the 12.x release numbers). You’ll find the
details at <a href="https://saxonica.com/saxon-c/1199/">https://saxonica.com/saxon-c/1199/</a>.
</p>

<p>If you decide to
<a href="https://en.wiktionary.org/wiki/kick_the_tires">kick the tyres</a><sup>†</sup>,
please do let us know how it goes. There’s still work to do with
installing and packaging, but we think the API is in good shape. (I
did notice that if you call <code>compile_stylesheet()</code> and the stylesheet
isn’t well formed, the call silently returns <code>None</code> instead of raising
an error. I’ve
<a href="https://saxonica.plan.io/issues/5781">reported that one</a>!)</p>

<p>I’ll probably check my email most days, but I can’t speak for
anyone else. Apologies if some of your feedback isn’t properly
addressed before the new year.</p>

<p>Once again, wishing you the happiest of holiday seasons!</p>

<div class="fn">
<hr/>
<sup>†</sup>That’s “tires” for my American friends.
</div>
</div></content></entry><entry><title>Signed, sealed, and delivered</title><link href="https://blog.saxonica.com/norm/2022/12/21-net6.html" rel="alternate" type="text/html"/><id>https://blog.saxonica.com/norm/2022/12/21-net6.html</id><published>2022-12-21T13:19:00Z</published><content type="xhtml" xml:base="https://blog.saxonica.com/norm/2022/12/21-net6.html"><div xmlns="http://www.w3.org/1999/xhtml">
<h1>Signed, sealed, and delivered</h1>

<p>I have been trying to build SaxonCS for .NET such that I could deliver it
on MacOS without warning messages for
<a href="https://github.com/dotnet/sdk/issues/24337">a long time</a>.
It has not been an easy or enjoyable adventure. Here are some
breadcrumbs for the next poor soul forced to tread down this path.</p>

<p>You can’t do this with .NET 5. That’s probably less important today
than it was when I started. I don’t understand the details, but something has
been fixed in .NET 6 that isn’t going to be backported to .NET 5. (There’s
a comment to that effect in an issue, but I can’t now locate that issue.)</p>

<p>There are several problems that have to be solved. The application
has to be built such that it will run when signed. All of the various pieces
have to be (correctly) signed. A DMG must be constructed to distribute
the application (maybe I don’t <em>have</em> to do this step, but it’s
reasonably what users expect). The <em>DMG</em> has to be signed.
<em>And</em> the whole thing has to be notarized by Apple so that
it will open without warnings.</p>

<div>
<h2>The objective</h2>
<p>A complete, hands off, CI-driven build of a C# application to produce
a MacOS DMG file that a user can open and use without any warnings about
unsigned code or potentially malicious applications.</p>
</div>

<div>
<h2>Prerequisites</h2>

<p>Before you begin, there are some things you have to have setup.</p>

<ul>
<li><p>You need <a href="https://dotnet.microsoft.com/en-us/">dotnet</a> 6
(or later, I assume, but we’re planning to ship Saxon 12 with .NET 6
so that’s what I’m using).</p></li>
<li><p>You need the
<a href="https://learn.microsoft.com/en-us/nuget/install-nuget-client-tools">nuget</a>
command line tool. This is distinct from the <em>nuget</em> subcommand
of the <em>dotnet</em> tool. As far as I can tell, only the former
can actually install packages.</p>
<p>On a Mac, you need the Mono framework and some
other fiddling to make it work. Because that’s the way it is. The details
are outlined on the tools page linked above.</p>
</li>
<li><p>You’ll need
<a href="https://developer.apple.com/xcode/">XCode</a>. I’m using version 14.2.
I think you need to install the XCode command line tools and you need to run
XCode at least once, it does a bunch of initialization the first time it runs.
</p></li>
<li><p>You need an Apple developer account and you have to go through
the dance necessary to create a developer ID certificate. The certificate
and (at least some of) the certificate chain need to be downloaded and
installed in your keychain. I don’t remember the exact details, but I seem
to recall that it was spelled out <em>reasonably</em> well in the Apple developer
documentation.</p>
</li>
<li><p>I decided to use
<a href="https://www.araelium.com/dmgcanvas">DMG Canvas</a> to build the
DMG. In addition to building the DMG, this application does the sign
and notarize dance with Apple for me. $20 well spent, I think. I
assume these steps can be done manually, but I’m not inspired to try
to figure out how just at the moment.</p>
</li>
</ul>

<p>Use the <em>nuget</em> command to install <code>Dotnet.Bundle</code>:</p>

<pre><code>$ nuget install Dotnet.Bundle</code></pre>

<p>This package constructs the “bundle” of files that MacOS expects
for an application. (That’s the <code><em>application</em>.app</code> directory
and its descendants.)</p>
</div>

<div>
<h2>Application files</h2>

<p>Start with your application. In our case, this complex beast:</p>

<pre><code>using System;

namespace HelloWorld
{
    public class HelloWorld
    {
        public static void Main(string[] arg)
        {
            Console.WriteLine("Hello, World!");
        }
    }
}</code></pre>

<p>You will also need a <code>.csproj</code> file. Here’s one that works
for me:</p>

<pre><code>&lt;Project Sdk="Microsoft.NET.Sdk"&gt;

  &lt;PropertyGroup&gt;
    &lt;PlatformTarget&gt;AnyCPU&lt;/PlatformTarget&gt;
    &lt;DebugType&gt;pdbonly&lt;/DebugType&gt;
    &lt;Optimize&gt;true&lt;/Optimize&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;TargetFramework&gt;net6.0&lt;/TargetFramework&gt;
    &lt;PublishSingleFile&gt;true&lt;/PublishSingleFile&gt;
    &lt;SelfContained&gt;true&lt;/SelfContained&gt;
    &lt;PublishReadyToRun&gt;true&lt;/PublishReadyToRun&gt;
    &lt;RuntimeIdentifier&gt;osx-x64&lt;/RuntimeIdentifier&gt;
    &lt;UseHardenedRuntime&gt;true&lt;/UseHardenedRuntime&gt;
    &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;
    &lt;Nullable&gt;enable&lt;/Nullable&gt;
    &lt;IncludeNativeLibrariesForSelfExtract&gt;true&lt;/IncludeNativeLibrariesForSelfExtract&gt;
    &lt;IncludeSymbolsInSingleFile&gt;false&lt;/IncludeSymbolsInSingleFile&gt;
  &lt;/PropertyGroup&gt;

  &lt;PropertyGroup&gt;
    &lt;CFBundleName&gt;HelloWorld&lt;/CFBundleName&gt;
    &lt;CFBundleDisplayName&gt;HelloWorld&lt;/CFBundleDisplayName&gt;
    &lt;CFBundleIdentifier&gt;com.saxonica.helloworld&lt;/CFBundleIdentifier&gt;
    &lt;CFBundleVersion&gt;1.0.0&lt;/CFBundleVersion&gt;
    &lt;CFBundleShortVersionString&gt;1.0.0&lt;/CFBundleShortVersionString&gt;
    &lt;CFBundleExecutable&gt;HelloWorld&lt;/CFBundleExecutable&gt;
    &lt;CFBundleIconFile&gt;HelloWorld.icns&lt;/CFBundleIconFile&gt;
    &lt;NSPrincipalClass&gt;NSApplication&lt;/NSPrincipalClass&gt;
    &lt;NSHighResolutionCapable&gt;true&lt;/NSHighResolutionCapable&gt;
    &lt;NSRequiresAquaSystemAppearance&gt;false&lt;/NSRequiresAquaSystemAppearance&gt;
  &lt;/PropertyGroup&gt;

  &lt;ItemGroup&gt;
    &lt;PackageReference Include="DotNet.Bundle" Version="0.9.13" /&gt;
  &lt;/ItemGroup&gt;

&lt;/Project&gt;</code></pre>

<p>The first property group specifies properties of the build, the second
defines how the application will be bundled, and the last item group is
necessary to make the bundler part of the build.</p>

<p>Notes:</p>

<ol>
<li>You must specify <code>net6</code> for the framework and create
a single file, self-contained application.</li>
<li>You must use the hardened runtime.</li>
<li>You must include native libraries for self extraction.</li>
<li>You must <em>not</em> include symbols in the single file, that’s an option that
apparently stopped working in .NET 5.</li>
<li>I created <code>HelloWorld.icns</code> from a PNG with ImageMagick.</li>
</ol>
</div>

<div>
<h2>Building the application</h2>

<p>Add <code>Dotnet.Bundle</code> to the project:</p>

<pre><code>$ dotnet add package Dotnet.Bundle</code></pre>

<p>(You only have to do this once.)</p>

<p>Build the application:</p>

<pre><code>$ dotnet msbuild -t:BundleApp -p:RuntimeIdentifier=osx-x64 -p:Configuration=Release</code></pre>

<p>You can run the bundled application to make sure it works:</p>

<pre><code>$ bin/Release/net6.0/osx-x64/publish/HelloWorld.app/Contents/MacOS/HelloWorld
Hello, World!</code></pre>
</div>

<div>
<h2>Sign the application</h2>

<p>Next we have to sign the application. But before we can do that, we have
to make an entitlements plist file. I called mine <code>entitlements.plist</code>:</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN"
          "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
    &lt;key&gt;com.apple.security.cs.allow-jit&lt;/key&gt;
    &lt;true/&gt;
    &lt;key&gt;com.apple.security.cs.allow-unsigned-executable-memory&lt;/key&gt;
    &lt;true/&gt;
    &lt;key&gt;com.apple.security.cs.disable-library-validation&lt;/key&gt;
    &lt;true/&gt;
    &lt;key&gt;com.apple.security.cs.disable-executable-page-protection&lt;/key&gt;
    &lt;true/&gt;
&lt;/dict&gt;
&lt;/plist&gt;</code></pre>

<p>Now we can sign it:</p>

<pre><code>$ codesign --force --options runtime --entitlements ./entitlements.plist --deep \
  --sign "Developer ID Application: YOUR DEVELOPER ID GOES HERE" \
  --timestamp bin/Release/net6.0/osx-x64/publish/HelloWorld.app</code></pre>

<p>You must use the entitlements option and the timestamp option. (You probably
need all the other options too, but those were the ones that I initially 
overlooked.)</p>

<p>You can run it again to make sure it still works:</p>

<pre><code>$ bin/Release/net6.0/osx-x64/publish/HelloWorld.app/Contents/MacOS/HelloWorld
Hello, World!</code></pre>

<p>(It didn’t for me for the longest time!)</p>
</div>

<div>
<h2>Construct the DMG</h2>

<p>Fire up the <em>DMG Canvas</em> application. (Yes, I know, I said I wanted this to
be a hands-off process. I believe <em>DMG Canvas</em> can be automated, but I haven’t
tried to figure out exactly how yet.)</p>

<p>The first time you open it up, go to the Preferences dialog and add your Apple ID
and a one-time password on the Notarization tab:</p>

<figure>
<img src="img/app-password.png" alt="Screen capture of the DMG Canvas notarization preferences tab."/>
</figure>

<p>This will enable signing and notarizing the DMG later.</p>

<p>On the main screen, add the application to the canvas. On the right hand
side, choose the second tab and select “Code Sign and Notarize” in the drop down.
You’ll have to specify the certificate you want to use, your Apple ID, and the primary
bundle ID. (I have no idea what that means in this context, but you have to put
something in there.)</p>

<figure>
<img src="img/app-main.png" alt="Screen capture of the DMG Canvas main screen with the notarization dialog shown on the right."/>
</figure>

<p>Click the “Build” button in the upper right corner, fill in the details,</p>

<figure>
<img src="img/app-build.png" alt="Screen capture of the DMG Canvas build dialog."/>
</figure>

<p>Hit Save and wait (nervously, and for quite a while) for the results!</p>

<figure>
<img src="img/app-wait.png" alt="Screen capture of the DMG Canvas modal dialog while it's building and notarizing the DMG file."/>
</figure>

<p>With luck, it all goes smoothly and you get back a signed, notarized DMG file.</p>

<p>There’s obviously more to be done in the DMG: it needs a background image, the
standard symlink to <code>/Applications</code> should be present, etc. But
I got a <a href="HelloWorld.dmg">working DMG</a> file out of it so, I’m
declaring victory for the moment.</p>

</div>
</div></content></entry><entry><title>SaxonCS for .NET 6</title><link href="https://blog.saxonica.com/norm/2022/08/09-net6.html" rel="alternate" type="text/html"/><id>https://blog.saxonica.com/norm/2022/08/09-net6.html</id><published>2022-08-09T17:06:00Z</published><content type="xhtml" xml:base="https://blog.saxonica.com/norm/2022/08/09-net6.html"><div xmlns="http://www.w3.org/1999/xhtml">


<p>We first published SaxonCS 11.x using .NET 5. Since then, .NET 5
has reached “end of life” and .NET 6 has become the recommended “long
term service” release of the .NET framework.</p>

<p>This puts us in a bit of a bind.</p>

<p>On the one hand, we try not to make disruptive changes in a
maintenance release if we can avoid it. Consequently, we’re
reluctant to suddenly require all of our customers who might be
building applications with SaxonCS 11.x to upgrade to .NET 6 just
because they want to install a new maintenance release.</p>

<p>On the other hand, it is becoming difficult to support .NET 5
applications in some environments. Ubuntu 22.04, for example, doesn’t
ship with the SSL libraries that .NET 5 requires. This makes it
difficult, perhaps impossible, to deploy SaxonCS 11.x built with .NET 5 in some
environments.</p>

<p>As a compromise, we’ve published a set of SaxonCS 11.4 releases
built against .NET 6. In order to distinguish them from their .NET 5
counterparts, we’ve named them “SaxonCS-b6”. The “b6” is both a nod
towards their .NET 6 provenance and a way of identifying them as
“beta”. There are no code changes in these builds, they should perform
exactly as the SaxonCS 11.4 release does, but they have not been
tested extensively.</p>

<p>They are identified as “SaxonCS-b6 11.4.1”. You can get the
platform-specific release artifacts from our downloads area and the
NuGet package has been uploaded and should be available soon.</p>

<p>(Speaking of NuGet, I should also confess that I published the
wrong SaxonCS 11.4.0 artifact. The SaxonCS 11.4.0 release on NuGet
will only work on 64 bit platforms. I republished the corrected,
architecture independent release as SaxonCS 11.4.1 yesterday.)</p>

<p>We’ll have to cross this bridge again if we publish another Saxon
11.x maintenance release. Please let us know what works for you, and what doesn’t.</p>

</div></content></entry><entry><title>Triaging the bug lists…</title><link href="https://blog.saxonica.com/norm/2022/06/15-saxonjs.html" rel="alternate" type="text/html"/><id>https://blog.saxonica.com/norm/2022/06/15-saxonjs.html</id><published>2022-06-15T16:15:00Z</published><content type="xhtml" xml:base="https://blog.saxonica.com/norm/2022/06/15-saxonjs.html"><div xmlns="http://www.w3.org/1999/xhtml">


<p>The very observant among you may have noticed me making a bunch of changes to
the
<a href="https://saxonica.plan.io/projects/saxon-js/issues">SaxonJS
issues list</a> this afternoon. We’ve started planning for SaxonJS 3.0 and we’ve made
a couple of early passes over the issues list.</p>

<p>Today, I tried to make the actual issues list reflect some of those
tentative plans. I’ve added “SaxonJS 3.0” as a milestone to a bunch of
issues and I’ve moved some of the priorities around.</p>

<p>Don’t read <em>too</em> much into that at the moment. For one
thing, there’s almost certainly too much on the list, for another
I expect we’ll do at least one more maintenance release of 2.x before we get to 3.0.
</p>

<p>But we have to start somewhere. Feedback welcome.</p>
</div></content></entry><entry><title>The pattern match="para except appendix//para"
      </title><link href="https://blog.saxonica.com/mike/2022/05/except-patterns.html" rel="alternate" type="text/html"/><id>https://blog.saxonica.com/mike/2022/05/except-patterns.html</id><published>2022-05-26T15:15:00Z</published><content type="xhtml" xml:base="https://blog.saxonica.com/mike/2022/05/except-patterns.html"><div xmlns="http://www.w3.org/1999/xhtml">
        <h1>The pattern <code>match="para except appendix//para"</code></h1>
        
        <p>If you saw this pattern in an XSLT stylesheet, I can guess your reaction: <i>I haven't
        seen a pattern like that before. Cool, a neat way of matching paragraphs that aren't in
        an appendix. Must remember that and use it myself.</i></p>
        
        <p>Sadly, it doesn't do what you think. Consider this input document:</p>
        
        <pre><code>
&lt;appendix id="A"&gt;
    &lt;section id="A.1"&gt;
        &lt;para&gt;Ipsum lorem.&lt;/para&gt;
    &lt;/section&gt;
&lt;/appendix&gt;                   
        </code></pre>
        
        <p>You'd probably be as surprised as I was to see that the <i>Ipsum lorem</i> paragraph in this
            example matches the pattern <code>para except appendix//para</code>.</p>
        
        <p>To see why this is true, go to the spec, section 5.5.3: </p>
        
        <p>An item <i>N</i> matches a pattern <i>P</i> if the following applies, where <i>EE</i> is the equivalent expression to <i>P</i>: 
            <i>N</i> is a node, and the result of evaluating the expression <code>root(.)//(EE)</code> with a singleton 
            focus based on <i>N</i> is a sequence that includes the node <i>N</i>.</p>
        
        <p>So, this is saying that a node matches the pattern if it is selected by the expression <code>root(.)//(para except appendix/para)</code>.
        Assuming that we're in a tree rooted at a document node, that means it must be selected by the expression 
        <code>/descendant-or-self::node()/(para except appendix//para)</code>.</p>
        
        <p>Now, in our example document, one of the nodes selected by <code>/descendant-or-self::node()</code> is the <code>section</code> element;
            and when we evaluate <code>(para except appendix//para)</code> starting at the <code>section</code> element, the first operand
            (<code>para</code>) selects our paragraph, and the second operand (<code>appendix//para</code>) doesn't select it, so
        the expression as a whole selects it, and therefore it matches the pattern.</p>
        
        <p>That's totally counter-intuitive, and it's certainly not what the Working Group intended. It's a nasty bug. So the question is,
        what can we do about it, given that this is a published spec and there are implementations out there, and user applications that
        depend on it?</p>
        
        <h2>Is there anything we can do about it?</h2>
        
        <p>Perhaps we should start by asking: what would we like the spec to say, if we had the opportunity to change it?</p>
        
        <p>Given that we already have a special rule for patterns with a top-level <code>union</code> operator (see §6.5 rule 2),
        we could add a special rule for patterns with a top-level <code>intersect</code> or <code>except</code>
            operator: a pattern of the form <code>A except B</code> matches an item if pattern <i>A</i> matches the item and 
            pattern <i>B</i> does not. (And analagously for <code>intersect</code>.)</p>
        
        <p>If that's what we think we need to do, that leaves two challenges:</p>
        
        <ul>
            <li>Changing the spec (given there is no longer a Working Group to maintain it).</li>
            <li>Changing the Saxon implementation.</li>
        </ul>
        
        <p>Starting with the second point, there are several possibilities:</p>
        
        <ul>
            <li>Just do it, and hope we don't break any existing applications.</li>
            <li>Support both the old and new semantics concurrently, with some mechanism for selecting which to use. (Which should
            be the default? We want new users not to fall into the elephant trap, but we also don't want to break working applications.)</li>
            <li>Deprecate the syntax, and provide new syntax for the new semantics (e.g. operators spelled <code>and-also</code> or
            <code>but-not</code>). Note however, that it's likely most applications currently using <code>except</code> in a pattern
            are using unproblematic patterns like <code>@* except @code</code>.</li>
        </ul>
        
        <p>The third option seems the most satisfactory. And that suggest a route forward for the spec: in XSLT 4.0, if and when we
        manage to get it defined, deprecate the <code>except</code> and <code>intersect</code> operators at the top level of a pattern,
        and replace them with new operators that have the expected intuitive semantics.</p>
        
    
    </div></content></entry><entry><title>XML versus JSON: A Comparison using the XMark Benchmark</title><link href="https://blog.saxonica.com/mike/2022/05/xml-vs-json.html" rel="alternate" type="text/html"/><id>https://blog.saxonica.com/mike/2022/05/xml-vs-json.html</id><published>2022-05-06T11:00:00Z</published><content type="xhtml" xml:base="https://blog.saxonica.com/mike/2022/05/xml-vs-json.html"><div xmlns="http://www.w3.org/1999/xhtml">
        
        
        <p>For many years we have used the XMark benchmark to check for performance
        regression between Saxon releases, and to evaluate the impact of internal
        changes on query performance.</p>
        
        <p>XMark originated with the MonetDB project and is described at
            <a href="https://projects.cwi.nl/xmark/">https://projects.cwi.nl/xmark/</a>. It consists
        of a scaleable XML data file (produced using a data generator), and a set of 20 XQuery queries
        to be run against that data file. We have run the data generator to produce files with
        nominal sizes of 100Kb, 1Mb, 4Mb, 10Mb, and 100Mb; we use the original queries as published,
        except for one or two small changes to correct errors in the original publication.</p>
        
        <p>Recently we have converted these data files to JSON, and have produced equivalent XQuery 3.1
        queries to deliver the same results as the original. The queries still produce XML rather than JSON
        output, so that we can compare the results; except in a few cases where large chunks of the original
        XML are copied to the output, which we cannot reproduce exactly because we don't have the original
        XML available. The results also differ because JSON maps don't retain order.</p>
        
        <p>In this article I will report first on the data conversion; then on the query conversion;
        and finally on performance results.</p>
        
        <h2>Converting the data</h2>
        
        <p>I didn't attempt to use any off-the-shelf XML-to-JSON conversion tools. My instinct is that they
        wouldn't have done a very good job, and I would have needed an XSLT transformation to refine the output
        anyway, so I decided to do the whole job using XSLT 3.0.</p>
        
        <p>The conversion stylesheet is not particularly interesting; in fact, it's rather tedious. A few points
        are worth mentioning:</p>
        
        <ul>
            <li><p>As mentioned in <a href="/mike/2021/06/arrays.html">What should
            we do about arrays?</a> the XSLT 3.0 spec is weak on capabilities for constructing arrays. This
            is the only area where we used Saxon extensions. I'm not convinced we yet have a perfect solution to this
            problem, and I've proposed some new ideas at <a href="https://github.com/qt4cg/qtspecs/issues/113">Constructing Arrays</a>.</p></li>
            <li><p>The XMark data files are mainly structured data, but there is some use of mixed content for narrative
            text. Mixed content is bad news for JSON. In real life, I would probably have handled this by embedding
            XML or HTML fragments within character strings in the JSON structure; but that seemed to be against
            the spirit of this exercise, so I instead expanded the node structure of the mixed content using JSON
            maps and arrays. As we'll see later, this had a severe effect on the ease of writing the queries
            and on their performance.</p></li>
            <li><p>Most structured data elements in the original file fall into two categories: elements
            with homogenous element content (multiple children all having the same name), and elements
            with heterogeous element content (multiple children with different names). These translate very
            naturally into JSON arrays and maps respectively. A few cases weren't quite so simple: for example
            the content model for <code>open_auction</code> has the form <code>(initial, bidder*, current,
            privacy, seller, ...)</code>. We handle this as if there were a wrapper element <code>bidders</code>
            around the sequence of <code>bidder</code> elements, so <code>open_auction</code> translates
            to a map, and <code>bidders</code> converts to an array. The names of elements within an array
            are generally dropped.</p></li>
            <li><p>There are a few attributes in the XML; these posed no particular problem.</p></li>
        </ul>
        
        <p>The nominal 10Mb file is actually 11,875,066 bytes in its XML form, and 10,464,266 bytes
        when converted to JSON, a reduction of 13%. Some of this difference (perhaps 200Kb) is due to 
        unnecessary whitespace in the XML; the rest is the overhead of element end tags.</p>
        
        <p>Parsing the XML and building a Saxon TinyTree took 353ms; parsing the JSON and building a structure
        of XDM maps and arrays took 636ms. I haven't attempted to assess the memory usage of the two data structures,
        but the maps and arrays are almost certainly larger. This is despite the fact that for maps derived directly
        from JSON parsing, we use a specialized representation of maps that optimizes for the fact that all keys
        are instances of <code>xs:string</code>, and therefore don't need to retain a type annotation.</p>
        
        <h2>Converting the Queries</h2>
        
        <p>The queries were converted by hand. Generally we tried to change the query so it continued to produce
        the same (XML) output as the original, for ease of comparing results; but for queries whose output copies
        sizeable chunks of the input XML, we abandoned this principle, instead replicating the intent of the query
        as far as we could.</p>
        
        <p>In most cases the conversion is very straightforward. For example, this is Q3:</p>
        
        <pre><code>
(: Q3. Return the IDs of all open auctions whose current
     increase is at least twice as high as the initial increase. :)

for    $b in /site/open_auctions/open_auction
where  $b/bidder[1]/increase * 2 &lt;= $b/bidder[last()]/increase
return &lt;increase first="{$b/bidder[1]/increase}"
                 last="{$b/bidder[last()]/increase}"/&gt;            
            
        </code>           
        </pre>
        
        <p>Which turns into:</p>
        <pre><code>
(: Q3. Return the IDs of all open auctions whose current
     increase is at least twice as high as the initial increase. :)

for    $b in ?open_auctions?*
where  $b?bidders?*[1]?increase *2 &lt;= $b?bidders?*[last()]?increase
return &lt;increase first="{$b?bidders?*[1]?increase}"
                 last="{$b?bidders?*[last()]?increase}"/&gt;
        </code>           
        </pre>
        
        <p>Some observations:</p>
        
        <ul>
            <li>We have to use <code>bidders?*[1]</code> rather than <code>bidders?1</code> because
            the latter expression throws a dynamic error (rather than returning an empty sequence)
            for an auction in which there are no bidders.</li>
            <li>We use <code>bidders?*[last()]</code> to get the last item in an array
            because converting the array to a sequence and using a filter is simpler than the alternative of
            writing <code>bidders?(array:size($b?bidders))</code>.</li>
            <li>The element name <code>site</code> is dropped because the JSON file is a map in which
            <code>open_auctions</code> is a top-level entry.</li>
            <li>The element name <code>open_auction</code> is dropped because the 
                <code>open_auctions</code> entry in the JSON contains an array of objects which do
                not need to be named; the <code>?*</code> in the JSON query corresponds to the
                <code>/open_auction</code> in the original.</li>
            <li>The JSON form introduces the name <code>bidders</code> as a wrapper for the group of
            individual <code>bidder</code> elements in the XML (which become anonymous in the JSON).</li>
        </ul>
        
        <p>Some specific difficulties that were encountered in converting other queries:</p>
        
        <ul>
            <li>Query Q4 looks for auctions where one bid differs from a previous bid, and for this
            purpose it uses the operator <code>&lt;&lt;</code> to test the relative order of two
            nodes in document order. The JSON model offers no equivalent. To solve this I introduced
            a higher-order function <code>index-where(array, predicate)</code> which returns the
            index positions in an array of members that satisfy the given predicate; it is then possible
            to find the required two items and compare their index positions.</li>
            <li>For any query using the mixed content <code>description</code> field, I needed to include
            a recursive function that reconstructs the <code>description</code> as text by flattening
            the arrays and maps that make it up. This is tedious and expensive. Queries that do a deep dive
            into the description, like looking for text marked up with <code>keyword</code> tags at any
            depth, are even more complicated. The <code>map:find</code> function sometimes does what's needed,
            but not if any context is involved (for example, finding a keyword that's nested within 
            <code>emph</code> markup).</li>
            <li>Debugging mistakes can be tricky. The diagnostics you get when you write 
                <code>?closed_auctions?annotation</code> instead of <code>?closed_auctions?*?annotation</code>
            aren't always helpful. I've tried to improve them. I've also proposed a language change so
            the first expression becomes valid: see <a href="https://github.com/qt4cg/qtspecs/issues/115">Lookup
            operator on arrays of maps</a>.</li>
            <li>It's very easy to forget that if <code>$A</code> is an array, then <code>$A[$index]</code>
            and <code>$A[condition]</code> are both valid, but neither means what you think, because they treat
            the array as a single item, not as a collection. With arrays derived from JSON, every member of the
            array (discounting any nulls) is a singleton, so you can always write <code>$A?*[$index]</code>
                or <code>$A?*[condition]</code> instead.</li>
        </ul>
        
        
        
        
        <h2>Query Performance</h2>
        
        <p>For most of the queries, the JSON query was a little slower than the XML version. 
            Queries in this category include: </p>
        
        <table>
            <thead>
                <tr>
                    <th>Query</th>
                    <th>XML timing (ms)</th>
                    <th>JSON timing (ms)</th>
                    <th>Ratio (%)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>q1</td>
                    <td>0.2649</td>
                    <td>0.6845</td>
                    <td>258%</td> 
                </tr>
                <tr>
                    <td>q2</td>
                    <td>0.4861</td>
                    <td>0.6588</td>
                    <td>136%</td> 
                </tr>
                <tr>
                    <td>q5</td>
                    <td>0.2711</td>
                    <td>0.3190</td>
                    <td>118%</td> 
                </tr>
                <tr>
                    <td>q8</td>
                    <td>1.9359</td>
                    <td>2.3572</td>
                    <td>122%</td> 
                </tr>
                <tr>
                    <td>q10</td>
                    <td>11.3329</td>
                    <td>14.3428</td>
                    <td>127%</td> 
                </tr>
                <tr>
                    <td>q11</td>
                    <td>93.5360</td>
                    <td>144.1105</td>
                    <td>154%</td> 
                </tr>
                <tr>
                    <td>q16</td>
                    <td>0.4183</td>
                    <td>0.8489</td>
                    <td>203%</td> 
                </tr>
                <tr>
                    <td>q17</td>
                    <td>0.5964</td>
                    <td>0.8887</td>
                    <td>149%</td> 
                </tr>
                <tr>
                    <td>q20</td>
                    <td>1.2380</td>
                    <td>2.2084</td>
                    <td>178%</td> 
                </tr>
            </tbody>
        </table>
        
        <p>How do we account for these numbers? My theory (based on gut feeling) is that the XML queries
        are faster because of the use of integer fingerprints for name matching in the TinyTree. Look at
        q1, for example, which in the original is:</p>
        
        <p>Q1: <code>for $b in /site/people/person[@id="person0"] return $b/name</code></p>
        
        <p>(The XMark queries were written by someone who felt that everything ought to be written
        as a FLWOR expression. It can of course be simplified to a simple XPath. I'm surprised
        they didn't use a <code>where</code> clause...)</p>
        
        <p>The child and attribute axis steps here (<code>child::people</code>, <code>child::person</code>, 
            <code>attribute::id</code>etc) are implemented
        in the TinyTree by a sequential search of node entries testing each one for an integer namecode. By contrast
        the JSON equivalent is:</p>
        
        <p>Q1: <code>for $b in ?people?*[?id="person0"] return $b?name</code></p>
        
        <p>and this involves string-based lookups in a hash table. Because the fan-out is fairly small, the
        sequential search wins.</p>
        
        <p><i>To test this theory, I ran the XML queries using DOM rather than TinyTree as the tree model. Navigation
            in the DOM uses string matching on element and attribute names. The DOM queries
        are dramatically slower than the TinyTree: q1: 0.2947 q2: 9.1684 q5: 5.1841 q8: 49.4798 q10: 116.8379 
        q11: 402.2151 q16: 6.5635 q17: 44.1887 q20: 179.2854.</i></p>
        
        <p>In the next group of queries, the JSON query is slightly faster:</p>
        
        <table>
            <thead>
                <tr>
                    <th>Query</th>
                    <th>XML timing (ms)</th>
                    <th>JSON timing (ms)</th>
                    <th>Ratio (%)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>q3</td>
                    <td>1.3507</td>
                    <td>1.2656</td>
                    <td>94%</td> 
                </tr>
                <tr>
                    <td>q6</td>
                    <td>0.2870</td>
                    <td>0.0316</td>
                    <td>11%</td> 
                </tr>
                <tr>
                    <td>q9</td>
                    <td>3.2959</td>
                    <td>2.2320</td>
                    <td>68%</td> 
                </tr>
                <tr>
                    <td>q12</td>
                    <td>32.3911</td>
                    <td>29.2320</td>
                    <td>90%</td> 
                </tr>
                <tr>
                    <td>q18</td>
                    <td>0.3134</td>
                    <td>0.2865</td>
                    <td>91%</td> 
                </tr>
                <tr>
                    <td>q19</td>
                    <td>4.9937</td>
                    <td>4.6699</td>
                    <td>93%</td> 
                </tr>
            </tbody>
        </table>
        
        <p>Query q6 is clearly an outlier. This query counts descendants: the original XML formulation is:</p>
        
        <p>Q6: <code>for $b in /site/regions/* return count ($b//item)</code></p>
        
        <p>As it happens, <code>item</code> elements cannot appear at any depth, so the return clause
        could equally have been written <code>count($b/item)</code>. In writing the JSON query I took
        advantage of this knowledge, and wrote the query as:</p>
        
        <p>Q6: <code>map:for-each(?regions, function($k, $v){a:size($v)})</code></p>
        
        <p>This runs faster firstly because of this simplification, and secondly because the size of a map
        can be determined in constant time, whereas counting the number of children of an element requires
        actually scanning them.</p>
        
        <p>For the other queries where there is a small speed-up, the cause is less obvious, but it's usually
        possible to hazard a guess. Some of them, for example, involve arithmetic and numeric comparisons,
        and the JSON queries in such cases avoid the overhead of converting strings to numbers on the fly
        (instead, the conversion is done during JSON parsing). We know from profiling that these conversions,
        especially if they occur in a filter predicate, can dominate query execution time.</p>
        
        <p>For the final group of queries, the JSON performance is chronically worse:</p>
        
        <table>
            <thead>
                <tr>
                    <th>Query</th>
                    <th>XML timing (ms)</th>
                    <th>JSON timing (ms)</th>
                    <th>Ratio (%)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>q7</td>
                    <td>1.0953</td>
                    <td>87.4869</td>
                    <td>7987%</td> 
                </tr>
                <tr>
                    <td>q13</td>
                    <td>0.3635</td>
                    <td>15.1646</td>
                    <td>4171%</td>
                </tr>
                <tr>
                    <td>q14</td>
                    <td>12.4252</td>
                    <td>138.0764</td>
                    <td>1111%</td>
                </tr>
            </tbody>
        </table>
        
        <p>These three queries all involve access to the <code>description</code> of an <code>item</code>, which in the XML representation
        is a mixed-content field (text with inline markup). As remarked earlier, this has been represented in JSON by expanding the
        node tree to a structure of arrays and singleton maps. As a result, a query like this one:</p>
        
        <p>Q14: <code>for $i in /site//item where contains ($i/description,"gold") return ($i/name, $i/description)</code></p>
        
        <p>becomes thoroughly contorted (and inefficient) in the JSON representation: it is necessary to write a recursive function
        that assembles the description (sans markup) as a string before executing the <code>contains()</code> function. Even then,
        the JSON query doesn't faithfully reproduce the original, because it outputs the description as a string, losing the internal
        markup.</p>
        
        <h2>Conclusions</h2>
        
        <p>First, if you've got mixed content (text with inline markup) then you probably don't want to be using JSON. If you must
        use JSON, use XML or HTML within character strings in cases where inline markup is needed.</p>
        
        <p>Secondly, for structured data it's a fairly even match; the differences aren't large enough to be critical for most
        applications. In Saxon, XML does slightly better on balance. This assumes, however, that for the XML case you are using 
        an efficient model like the Saxon TinyTree, rather than a general-purpose DOM.</p>
        
        <p>We found a few cases where the expressive power of XQuery 3.1 for querying JSON structures has gaps and omissions.
        Notably, searching for descendants in the tree is difficult; operations based on ordering of items within arrays are
        also tricky.</p>
            
    </div></content></entry><entry><title>SaxonJS with web components</title><link href="https://blog.saxonica.com/norm/2022/04/19-shoelace.html" rel="alternate" type="text/html"/><id>https://blog.saxonica.com/norm/2022/04/19-shoelace.html</id><published>2022-04-19T18:43:00Z</published><content type="xhtml" xml:base="https://blog.saxonica.com/norm/2022/04/19-shoelace.html"><div xmlns="http://www.w3.org/1999/xhtml">


<p>I haven’t worked with
<a href="https://en.wikipedia.org/wiki/Web_Components">web components</a> very much,
though they’ve been on my “must explore more” list for a while. A couple of days ago,
I stumbled across <a href="https://shoelace.style/">Shoelace</a>, “a forward-thinking
library of web components.”</p>

<p>“That’d just work in SaxonJS, right?”, I asked myself.</p>

<p>Yep. I updated the
<a href="https://github.com/Saxonica/helloWorldJS">helloWorldJS</a> repository
that I created a while back to demonstrate it.</p>

<p>The new work is in the <code>shoelace</code> branch.</p>

<p>There’s not much different, really.</p>

<ol>
<li>The HTML file includes the
Shoelace scripts and styling from its CDN. (A more robust application
would want local copies, but this is just a toy.)</li>
<li>Instead of using a <code>button</code> element, we use the Shoelace
web-component: <code>&lt;sl-button&gt;Click me&lt;/sl-button&gt;</code>.
</li>
<li>The match pattern for the onclick handler changes to
<code>match="sl-button"</code>.</li>
</ol>

<p>That’s pretty much all there is to it. Neat. I must try out some more web
components when I have a chance. In principle, the seem like a really good idea.</p>

</div></content></entry><entry><title>What should we do about Arrays?</title><link href="https://blog.saxonica.com/mike/2021/06/arrays.html" rel="alternate" type="text/html"/><id>https://blog.saxonica.com/mike/2021/06/arrays.html</id><published>2021-06-27T15:34:00Z</published><content type="xhtml" xml:base="https://blog.saxonica.com/mike/2021/06/arrays.html"><div xmlns="http://www.w3.org/1999/xhtml">
        
            
            <p>Arrays were added to the data model for XPath 3.1 (and XQuery 3.1): the main motivation 
                was the need for faithful representation of JSON data structures, while a secondary 
                consideration was the long-standing requirement for "sequences of sequences".
            </p>
            <p>Processing support for arrays in the current languages is rather limited. There's 
                a basic set of functions available, but not much else. Support in XSLT 3.0 is 
                particularly weak, because XSLT 3.0 was primarily designed to work with XPath 3.0 
                (which didn't have arrays), with 3.1 support added as something of an afterthought.
            </p>
            <p>This note surveys where the gaps are, and how they should be filled.
            </p>
            <p>Many of the complications in processing arrays arise because the members of an array 
                can be arbitrary sequences, not just single items. There were two reasons for this 
                design. One is simply orthogonality: the principle of no unnecessary restrictions. 
                The other was support for the JSON null value, which maps naturally to an empty 
                sequence in XDM, but only if an array is allowed have an empty sequence as one of its members.
            </p>
            
            <h2>Array Construction</h2>
            
            <p>XPath 3.1 offers two constructs for creating arrays: the "square" and "curly" 
                constructors. Neither is completely general. The "square" constructor (for 
                example <code>[$X, $Y, $Z]</code>) can construct an array with arbitrary values as its 
                members, but the size of the array needs to be known statically. The "curly" 
                constructor (for example <code>array{$X, $Y, $Z}</code>) can construct an array whose size 
                is decided dynamically, but the members of the array must be singleton items 
                (not arbitrary sequences). The WG failed to come up with a construct for creating 
                an array where both the size of the array and the size of each member are 
                determined dynamically. The only way to achieve this is with a fairly convoluted 
                use of functions such as <code>array:join()</code>.
            </p>
            <p>XSLT 3.0 has no mechanism for array construction. An <code>xsl:array</code> instruction has 
                been proposed, and is prototyped as <code>saxon:array</code> in current Saxon releases; 
                but the difficulty is in defining the detail of how it should 
                work. It makes sense for it to enclose a sequence constructor, so instructions 
                like <code>xsl:for-each</code> and <code>xsl:choose</code> can be used when building the content. 
                But sequence constructors deliver sequences of items, not sequences of sequences.
                So the current proposal for <a href="https://qt4cg.org/branch/master/xslt-40/Overview.html#array-construction">XSLT 4.0</a>
                envisages an <code>xsl:array-member</code> instruction that wraps a sequence as a zero-arity
                function. The problem with this is that the mechanism is transparent yet arbitrary;
                it looks like (and is) a kludge.
            </p>
            <h2>Array Processing</h2>
            
            <p>Similarly, there are limited options for processing of arrays. There's no 
                equivalent of the "for" clause in FLWOR expressions that binds a variable 
                to each member of an array in turn. The closest things on offer are the 
                <code>array:filter()</code> and <code>array:for-each()</code> higher order functions – which are 
                more useful in XQuery than in XSLT, because of the difficulty in XSLT 
                of writing an anonymous function that constructs new XML element nodes. 
                XSLT in particular relies heavily (in constructs such as <code>xsl:apply-templates</code>, 
                <code>xsl:for-each</code>, <code>xsl:iterate</code>, and <code>xsl:for-each-group</code>) on binding values implicitly 
                to the context item. But the context item is an item, not an arbitrary value, 
                so binding members of arrays to the context item isn't an option.
            </p>
            <p>Generalizing "." to represent an arbitrary value rather than a single item seems 
                an attractive idea, but it's very hard to do without breaking a lot of existing code.
            </p>
            <p>Iterating over an array and binding each member to a variable works well in XQuery,
            where adding a "for member" clause to FLWOR expressions works cleanly enough. But there's
            lots of other functionality for processing sequences that can't be translated easily
            into equivalent mechanisms for arrays, especially in XSLT.</p>
        
            <h2>Parcels</h2>
            
            <p>It seems that a solution for both array construction and array processing is to find 
                a way to pack an arbitrary sequence into a single item. We'll refer to a "sequence 
                packed into an item" as a parcel. We can then construct an array from a sequence 
                of parcels, and we can decompose an array into a sequence of parcels, allowing 
                both operations to be implemented using all the existing machinery for handling 
                sequences. 
            </p>
            <p>It seems that four operations are sufficient to fill the processing gap:
            </p>
            <ul><li>Wrap a sequence as a parcel</li>
            <li>Unwrap a parcel as a sequence</li>
            <li>Construct an array from a sequence of parcels</li>
            <li>Decompose an array into a sequence of parcels</li>
            </ul>
            <p>So four functions should do the job: <code>parcel(item()*) =&gt; P</code>, 
                <code>unparcel(P) =&gt; item()*</code>, <code>array:of(P*) as array(*)</code>, <code>array:members(array(*)) as P*</code>, 
                where <code>P</code> is the item type of a parcel. Of course, we can also add XSLT or XQuery syntactic 
                sugar on top of these building blocks.
            </p>
            <p>We now have to address the question: what kind of item is a parcel? Is it represented using something we 
                already know and love (like an array, or a zero-arity function) or is it something new? How should 
                the type of a parcel be represented in type signatures, and what operations (apart from the above four) 
                should be available on them?
            </p>
            <p>I'm beginning to come to the conclusion that the type safety that comes from treating a parcel as a 
                new kind of item justifies the extra complexity in the type system. If we reuse an existing 
                kind of item (for example, zero-arity functions), then there's always going to be confusion about 
                whether items of that type are to be treated as parcels or as their "ordinary selves".
            </p>
            <p>However, I'm reluctant to add yet another fundamental type. We can't keep adding fundamental 
                types, and new syntax, every time we need something new (cf my Balisage 2020 paper on adding 
                promises). Can't we make the type system more extensible?
            </p>
            <p>Pro tem, I suggest we build on the concept of "extension objects" defined in §25.1.3 of 
                the XSLT specification. These are intended as opaque objects that can be returned by 
                one extension function and supplied to another. This concept should really be defined 
                in XDM rather than in XSLT. We should add that an "extension object" may be an instance 
                of an "extension type", and that extension types are denoted in the ItemType syntax by a 
                QName (that is, the same syntax as atomic types), with the QName being made known to the 
                processor in some implementation-defined way. Then we reserve a namespace URI sys for 
                "built in extension types", and define sys:parcel as such a type.
            </p>
            
    </div></content></entry><entry><title>Saxon-JS 2.2</title><link href="https://blog.saxonica.com/norm/2021/05/11-saxon-js-22.html" rel="alternate" type="text/html"/><id>https://blog.saxonica.com/norm/2021/05/11-saxon-js-22.html</id><published>2021-05-11T12:00:00Z</published><content type="xhtml" xml:base="https://blog.saxonica.com/norm/2021/05/11-saxon-js-22.html"><div xmlns="http://www.w3.org/1999/xhtml">


<p>Saxon-JS 2.2
has been published on
<a href="https://saxonica.com/saxon-js/">Saxonica.com</a> and to the
<a href="https://www.npmjs.com/package/saxon-js">npm registry</a>!</p>

<p>This is a maintenance release that fixes a few bugs. The big one, to my mind, is resolving
the “global object” bug in Node.js. Previous releases of Saxon-JS always
created a global object named “<code>SaxonJS</code>”. This isn’t best practice on
Node.js and interfered with some platforms like
<a href="https://en.wikipedia.org/wiki/Electron_(software_framework)">Electron</a>
and <a href="https://en.wikipedia.org/wiki/Webpack">Webpack</a>.</p>

<p>Starting with 2.2, on Node.js, the global object no longer gets created.
If you’ve consistently used</p>

<pre><code>const SaxonJS = require('saxon-js');</code></pre>

<p>to load Saxon-JS, you’ll be fine. If you’ve used some other name
for the object, make sure that you refer to Saxon-JS exclusively by
that name. For example:</p>

<pre><code>const <b>sjs</b> = require('saxon-js');
const six = <b>sjs</b>.XPath.evaluate("3+3");
console.log(`six = ${six}`)</code></pre>

<p>We fixed a few other bugs as detailed in the
<a href="https://www.saxonica.com/saxon-js/documentation/index.html#!changes">change history</a>.
Thanks to everyone who took the time to report them!
</p>

</div></content></entry><entry><title>Saxon-CS says Hello World</title><link href="https://blog.saxonica.com/mike/2021/03/saxon_cs_hello_world.html" rel="alternate" type="text/html"/><id>https://blog.saxonica.com/mike/2021/03/saxon_cs_hello_world.html</id><published>2021-03-22T10:34:00Z</published><content type="xhtml" xml:base="https://blog.saxonica.com/mike/2021/03/saxon_cs_hello_world.html"><div xmlns="http://www.w3.org/1999/xhtml">
        <p>The Saxon product on .NET has been living on borrowed time for a while.
        It's built by converting the Java bytecode of the Java product to the 
        equivalent .NET intermediate language, using the open-source IKVM converter
        produced by Jeroen Frijters. Jeroen after many years of devoted service
        decided to give up further development and maintenance of IKVM a few
        years ago, which didn't immediately matter because the product worked
        perfectly well. But then Microsoft in 2019 announced that future
        .NET developments would be based on .NET Core, and IKVM has never supported
        .NET Core, so we clearly had a problem.</p>
        <p>There's a team attempting to produce a fork of IKVM that supports
        the new .NET, but we've never felt we could put all our eggs in that basket.
        In any case, we also have performance problems with IKVM that we've never
        managed to resolve: some applications run 5 times slower than Java, and
        despite a lot of investigation, we've never worked out why.</p>
        <p>So we decided to try a new approach, namely Java-to-C# source code
        conversion. After a lot of work, we've now achieved successful compilation
        and execution of a subset of the the code, and for the first time this
        morning, Saxon-CS successfully ran the minimal "Hello World" query.</p>
        <p>We're a long way from having a product we can release, but we can now
        have confidence that this approach is going to be viable.</p>
        <p>How does the conversion work? We looked at some available tools,
        notably the product from Tangible Solutions, and this gave us many
        insights into what could be readily converted, and where the remaining
        difficulties lay; it also convinced us that we'd be better off writing
        our own converter.</p>
        <p>The basic workflow is:</p>
        <ol>
            <li>Using the open source JavaParser library, parse the Java code, generate
            an XML abstract syntax tree for each module, and annotate the syntax tree with type information
            where needed.</li>
            <li>Using XSLT code, do a cross-module analysis to determine which methods override each other,
            which have covariant return types, etc: information needed when generating the C# code.</li>
            <li>Perform an XSLT transformation on each module to generate C# code.</li>           
        </ol>
        <p>We can't convert everything automatically, so there's a range of strategies we use to
        deal with the remaining issues:</p>
        <ul>
            <li>Some constructs can simply be avoided. We have trouble, for example, converting
            Java method references like <code>Item::toString</code>, because it needs a fair bit of 
            context information to distinguish the various possible translations. But it's no great
            hardship to write the Java code a different way, for example as a lambda expression
            <code>item -&gt; item.toString()</code>. Another example is naming conflicts: C# doesn't
            allow you, for example, to have a variable with the same name as a method in the containing
            class. It's no hardship to rename the variables so the problem doesn't arise.</li>
            <li>We can use Java annotations to steer the conversion. For example, sometimes
            we want to generate C# code that's completely unrelated to the Java code. We can move
            this code into a method of its own, and then add an annotation <code>@CSharpReplaceMethodBody</code>
            which substitutes different code for the existing method body. The annotation is copied
            into the XML syntax tree by the JavaParser, and our converter can pick it up from there.</li>
            <li>We already have a preprocessor mechanism to mark chunks of code as being excluded from
            particular variants of the product (such as Saxon-HE or Saxon-PE). We can make further use
            of this mechanism. However, it's limited by the fact that the code, prior to preprocessing,
            must be valid Java so that it works in the IDE.</li>
        </ul>
        <p>The areas that have caused most trouble in conversion are:</p>
        <ul>
            <li>Inner classes. C# has no anonymous inner classes, and its named inner classes correspond
            only to Java's static inner classes. Guided by the way the Tangible converter handles these,
            we've found a way of translating them that handles most cases, and we've added Java annotations
            that provide the converter with extra information where additional complexities arise.</li>
            <li>Enumeration types. C#'s enumeration types are much more limited than the equivalent in
            Java, because enumeration constants can't have custom methods associated with them. We distinguish
            three kinds of enumeration classes: singleton enumerations (used to implement classes that will
            only have a single instance); simple enumerations with no custom behaviour, which can be translated
            to C# enumerations very directly, and more complex enumerations, that result in the generation
            of two separate C# classes, one to hold the enumeration constants, the other to accommodate the
            custom methods.</li>
            <li>Generics. C# is much stricter about generic types than Java, because the type information
            is carried through to run-time, whereas in Java it is used only for compile-time type checking,
            which can be subverted by use of casting. So the rule in C# is, either use generics properly,
            or don't use them at all. We anticipated some of these issues a year or two ago when we
            first started thinking about this project: see 
                <a href="/mike/2020/01/java-generics-revisited.html">Java Generics Revisited</a>.
            The result is that the classes representing XDM sequences and sequence iterators no longer use
            generics, which has saved a lot of hassle in this conversion. But there are still many
            problems, notably (a) the type inference needed to support Java's diamond operator (as in 
            <code>new ArrayList&lt;&gt;()</code>, where an explicit type parameter is needed in C#),
            and (b) the handling of covariant and contravariant wildcards (<code>? extends T</code>,
            <code>? super T</code>.)</li>
            <li>Iterators and enumerators. A <code>for-each</code> loop in Java (<code>for (X x : collection)</code>)
                relies on the <code>collection</code> operand implementing the <code>java.lang.Iterable</code>
                interface. To translate this into a C# for-each loop (<code>foreach (X x in collection)</code>)
                the <code>collection</code> needs to implement <code>IEnumerable</code>. So we convert
                all Iterables to IEnumerables, and that means we have to convert Iterators to Enumerators.
                Unfortunately Java's <code>Iterator</code> interface doesn't lend itself to static
                translation to a c# <code>IEnumerator</code>: in Java, the <code>hasNext()</code>
                method is stateless (so you can call it repeatedly), whereas C#'s <code>MoveNext</code>
                changes the current position (so you can't). We're fortunate that we only make
                modest use of Java iterators; in most of the code, we use Saxon's <code>SequenceIterator</code>
                interface in preferance, and this converts without trouble. We examined all the cases
                where Saxon explicitly uses <code>hasNext()</code> and <code>next()</code>, and made
                sure these followed the discipline of calling <code>hasNext()</code> exactly once
            before each call on <code>next()</code>; with this discipline, converting the calls to
            <code>MoveNext()</code> and <code>Current</code> works without problems.</li>
            <li>Lambda expressions and delegates. In Java, lambda expressions can be used where the
            expected type is a <i>functional interface</i>; a functional interface in other ways is just
            an ordinary interface, and you can have concrete classes that implement it. So for example
            the second argument of <code>NodeInfo.iterateAxis(axis, nodeTest)</code> is a <code>NodeTest</code>,
            for which we can supply either a lambda expression (such as <code>it -&gt; it instanceof XSLExpose</code>),
            or one of a whole range of implementation classes such as a <code>SchemaElementTest</code>,
            which tests whether an element belongs to an XSD-defined substitution group. In C#, lambda expressions
            can only be used when the expected type is a delegate, and if the expected type is a delegate,
            then (in effect) a lambda expression is the only thing you can supply. The way we've handled this
            is generally to make the main method (like <code>iterateAxis()</code> expect a non-delegate
            interface, and then to supply a proxy implementation of this interface that accepts a delegate.
            It's not a very satisfactory solution, but it works.</li>
            
        </ul>
        <p>One area where we could have had trouble, but avoided it, is in the use of the Java
        <code>CharSequence</code> class. I wrote about this issue last year at
            <a href="/mike/2020/07/string-charsequence-ikvm-and-net.html">String, 
                CharSequence, IKVM, and .NET</a>. As described in that article, we decided to eliminate
        our dependence on the <code>CharSequence</code> interface. For a great many internal uses of strings
        in Saxon, we now use a new interface <code>UnicodeString</code> which as the name implies is much
        more Unicode-friendly than Java's <code>String</code> and <code>CharSequence</code>. It also reduces
        memory usage, especially in the TinyTree. But there is a small overhead in the places where we
        have to convert strings to or from <code>UnicodeStrings</code>, which we can't hide entirely:
        it represents about 5% on the bottom line. But it does make all this code much easier to port
        between Java and C#.</p>
        
        <p>What about dependencies? So far we've just been tackling the Saxon-HE code base, and that has
        very few dependencies that have caused any difficulty. Most of the uses of standard Java library
        classes (maps, lists, input and output streams, and the like) are handled by the converter,
        simply translating calls into the nearest C# equivalent. In some cases such as <code>java.util.Properties</code>
        we've written en emulation of the Java interface (or the parts of it that we actually use). In other
        cases we've redirected calls to helper methods. For example we don't always have enough type
        information to know whether Java's <code>List.remove()</code> should be translated to
        <code>List.Remove()</code> or <code>List.RemoveAt()</code>; so instead we generate a call on
        a static helper method, which makes the decision at runtime based on the type of the
        supplied argument.</p>
        
        <p>The only external dependency we've picked up so far is for handling big decimal numbers.
        We're currently evaluating the <code>BigDecimal</code> library from Singulink, which appears
        to offer all the required functionality, though its philosophy is sufficiently different
        from the Java <code>BigDecimal</code> to make conversion non-trivial.</p>
        
        <p>One thing I should stress is that we haven't written a general purpose Java to C# converter.
            Our converter is designed to handle the Saxon codebase, and nothing else. Some of the
            conversion rules are specific to particular Saxon classes, and as a general principle,
            we only convert the subset of the language and of the class library that we actually need.
            Some of the conversion rules assume that the code is written to the coding conventions
            that we use in Saxon, but which might not be followed in other projects.</p>
        
        <p>So, Hello World to Saxon-CS. There's still a lot of work to do, but we've reached a significant
        milestone.</p>
        
    </div></content></entry><entry><title>The Zeno Chain: a new data structure for XDM sequences</title><link href="https://blog.saxonica.com/mike/2021/03/zeno_chains.html" rel="alternate" type="text/html"/><id>https://blog.saxonica.com/mike/2021/03/zeno_chains.html</id><published>2021-03-18T15:34:00Z</published><content type="xhtml" xml:base="https://blog.saxonica.com/mike/2021/03/zeno_chains.html"><div xmlns="http://www.w3.org/1999/xhtml">
        <p>This article presents the Zeno Chain, a new data structure used
        to underpin the implementation of XDM sequences in Saxon. It is also
        designed to be capable of supporting XDM arrays, and might also have
        potential for holding long character strings.</p>
        <p>The current implementation of the Zeno Chain is a mutable list,
        but the design lends itself easily to creating an immutable variant.
        It also makes it easy to construct an immutable list from a mutable
        one, making it efficient to construct a sequence with in-situ
        modification, and then "freeze" it once construction is complete.</p>
        <p>Saxon currently uses a variety of structures for holding sequences
        and arrays. This variety is a problem in itself. Choosing the right
        structure for a particular scenario involves somewhat hit-or-miss 
        decision making; it would be better to have a single "all-rounder"
        structure that performs well in a variety of situations.</p>
        <p>There are of course vast numbers of data structures for sequences
        available in the computer science literature. One promising one,
        for example, is the "finger tree" which supports a wide range of
        access patterns efficiently. But it also has drawbacks: any tree
        structure that requires a node for each item in a list is going
        to have a large memory overhead when storing a long sequence, and
        the use of a fine-grained structure like this tends to mean that
        there is little locality of reference for memory addressing, leading
        to poor CPU caching performance.</p>
        <p>The Zeno chain stores a sequence as a list of lists of items:
        that is, it is a tree with a constant depth of 2. In the Java
        implementation, both levels of list are instances of 
        <code>java.util.ArrayList</code>. The key to the performance of the
            structure is managing the number and size of the second-level
            lists, which I call <i>segments</i>.</p>
        <p>In a list that is constructed by appending individual items
            on the end (a common scenario), the length of a segment
            increases the closer it is to the start. For a list of 20,000
            items, there are ten segments whose sizes are (8192, 4096, 4096, 
            2048, 1024, 256, 128, 64, 64, 32). (Now you know why I called
            it a Zeno chain.) The exact numbers don't matter
            here: what is important is that the total number of segments
            increases only logarithmically with the length of the sequence,
            and that the segments on the right are short, which makes further
            append operations efficient.</p>
        <p>In a list constructed by prepending individual items, the
            distribution of lengths will be the other way round: shortest
            segments near the front. In the rare case where both append and
            prepend operations occur, both ends will have short segments,
            while longer segments will cluster around the middle.</p>
        <p>Here's a summary of the major operations performed on the sequence:</p>
        <ul>
            <li><b>Append an item:</b> if the list is empty, construct a single
            segment of length 1. Otherwise, if the last segment has length &lt; 32,
            append to it. If the last segment is already full, coalesce the last segment with the previous
            segment if the previous segment has sufficient room; if not, work
            up the list to the start to find adjacent segments that can be merged.
            A segment is considered to have sufficient room for such expansion if its resulting size
            would not exceed 2^(N+5) where N is the distance of the segment
            from the right-hand end of the sequence; it's this formula that ensures
            that longer segments accumulate at the start of the sequence. If all
            segments in the sequence are full — that is, if the
            segment sizes are decreasing powers of two — then add a new segment. 
            Append operations essentially take constant time; 97% of them only
            affect the final segment.</li>
            <li><b>Prepend an item:</b> simply append in reverse.</li>
            <li><b>Get the Nth item:</b> search the master list of segments examining
            the sizes of the segments until
            the right segment is found, then get the item by addressing into the
            Java <code>ArrayList</code>. This takes logarithmic time. The average
            access time will be slightly higher in a list built by prepending items,
            because the chance of finding the required item in the first couple of
            segments is much lower.</li>
            <li><b>Subsequence:</b> make a new Zeno chain containing whole or part copies
            of the segments from the original chain that are in the required range.</li>
            <li><b>Iteration:</b> Keep two index positions, the index position in the master
            list, and the index position in the current segment, and use these indexes
            to retrieve the next item by calling <code>ArrayList.get()</code> twice.</li>
            <li><b>Sequence concatenation: </b> This is quite a common operation in
            XSLT and XPath, as it's the basis of the "flattening" operations such as
            <code>xsl:for-each</code>, <code>xsl:apply-templates</code>, and
            FLWOR expressions. The most direct approach is simply to concatenate the two
            master lists, leaving the segments unchanged. This however can lead to 
            fragmentation of the sequence, so we perform a reorganization to
            reduce the number of short segments. Specifically, working from the
            right hand end, if any segment is found to be shorter than both its
            immediate neighbours, we combine it with the left-hand neighbour
            and reduce the number of segments by one. This has the effect of reducing
            the incidence of short segments in the middle of the chain.</li>
            <li><b>Insertion, removal, and replacement: </b> these operations
            are comparatively rare. With the immutable version of the structure,
            an alteration affecting one of the larger segments will require copying
            of everything else in that segment. This isn't ideal: but it's better
            than copying the entire sequence, which is what often happens today.
            And the use of the Java <code>ArrayList</code> at least means that the
            copying is very fast.</li>
        </ul>
        <p>It's important to note that most operations on sequences don't actually
            result in a new sequence being constructed. Calling <code>tail()</code>,
            for example, doesn't copy any data: it delivers an iterator over a portion
            of the original sequence. The sequence only gets materialized if, for example
            the result is stored in a variable (and even then, not always).</p>
        <p>Saxon's default implementation for a sequence is simply a Java List.
            Appending an item to a list generally copies the whole list. Where Saxon
            can detect that this is going to be inefficient, it instead uses a structure
            called a Chain: this is effectively a tree of segments. But there's little
            serious attempt to manage the depth of the tree or the size of the segments,
            and the results in some cases can be rather poor.The Zeno chain offers
            a signficant improvement; it also looks as if it can be used for arrays
            as well as sequences.</p>
        <p>For managing long strings, I invented a similar structure, which I then
            discovered already existed in the literature and is known as a Rope:
            a Rope represents a string as a tree of substrings. The literature on
            Ropes describes how to keep the tree balanced, but it has nothing to say
            about how to decide how many substrings to hold, and how long to make them.
            The Zeno chain might turn out to provide an answer to that question.

        </p>
    </div></content></entry><entry><title>Saxon-JS 2.0.3</title><link href="https://blog.saxonica.com/norm/2021/01/08-saxon-js-203.html" rel="alternate" type="text/html"/><id>https://blog.saxonica.com/norm/2021/01/08-saxon-js-203.html</id><published>2021-01-08T15:41:00Z</published><content type="xhtml" xml:base="https://blog.saxonica.com/norm/2021/01/08-saxon-js-203.html"><div xmlns="http://www.w3.org/1999/xhtml">


<p>Happy New Year!</p>

<p>As of a few minutes ago (at time of publication!), Saxon-JS 2.0.3
has been published to the
<a href="https://www.npmjs.com/package/saxon-js">npm registry</a>.
This release contains no changes in functionality (this is not the
release you’ve been waiting for, we’re still working on that one).</p>

<p>The previous version has a published dependency on
<a href="https://www.npmjs.com/package/axios">axios</a> version 
0.19.2 which is, apparently, the subject of a security vulnerability
(or so <code>npm install</code> asserted this morning).</p>

<p>This tiny release simply updates the dependency to a patched
version of axios.</p>

<p>Axios is an HTTP library that is only used by the NodeJS version of
Saxon-JS. When Saxon-JS is running in the browser, it uses the
browser’s APIs, so this update should have no consequences for the
browser version at all.</p>

</div></content></entry><entry><title>Arrow Expressions</title><link href="https://blog.saxonica.com/mike/2020/11/19-arrow-expressions.html" rel="alternate" type="text/html"/><id>https://blog.saxonica.com/mike/2020/11/19-arrow-expressions.html</id><published>2020-11-19T10:20:00Z</published><content type="xhtml" xml:base="https://blog.saxonica.com/mike/2020/11/19-arrow-expressions.html"><div xmlns="http://www.w3.org/1999/xhtml">
    <h2>Arrow Expressions</h2>
    <p>When I proposed the arrow operator to the XQuery/XSLT working groups, I thought of it as minor syntactic sugar.
    It's just a convenience: instead of <code>substring-before(substring-after(X, '['), ']')</code> you can write
    <code>X =&gt; substring-after('[') =&gt; substring-before(']')</code> which helps you to avoid going cross-eyed.
    If you're the kind of person who can play the piano with your hands crossed over, you probably don't need it,
    but for the rest of us, it makes life just a tiny bit easier.</p>
    <p>So I was a bit surprised at XML Prague 2020 that Juri Leino managed to construct an entire
            presentation around the arrow operator 
            (<a href="https://speakerdeck.com/minuso/shooting-arrows-fast-and-accurately">Shooting Arrows Fast and Accurately</a>).
          Not only that, he also developed a whole library of functions, called XBow, to increase their power.</p>
    <p>Now, XBow actually reveals a bit of a weakness in the construct: you can construct a pipeline of functions,
          but you can't include arbitrary expressions in the pipeline unless each of the expressions is made available
          via a function. Moreover,
          the value output by one step in the pipeline can only be used as the first argument in the next function: you
          can do <code>X =&gt; concat('$')</code> to add a "$" at the end of a string, but there's no simple way of adding
          a "$" at the front, except by defining a new <code>prepend</code> function that does this for you (or hoping
            that XBow will have anticipated your requirement).</p>
    <p>Now, of course you can do <code>X ! concat('$', .)</code>. But that doesn't always fit the bill. Firstly,
          it only works when you're processing single items (or mapping a sequence to multiple items). Secondly,
          (to use the current jargon) the optics are wrong: it breaks the pipeline visually.</p>
    <p>So my first suggestion is that we allow inline expressions to appear in a pipeline. Something like this:
          <code>X =&gt; {~ + 1}</code>, or <code>X =&gt; {concat('$', ~)}</code>. 
            I'm using '~' here as a variable to refer to the
          implicit argument, that is, the value passed down the pipeline. I would have used '_', as Scala does, but unfortunately
          '_' is a legal element name so it already has a meaning. And '~' seems to work quite nicely.</p>
    <p>The next thing that's been requested is implicit mapping, so you can use something like arrow notation
          to do <code>X ! substring-after(., '$') ! number(.) =&gt; sum()</code>. (Actually, the main obstacle in getting
          the arrow operator accepted by the XQuery Working Group was that some people wanted it to have this meaning.)</p>
    <p>For that I propose we use a "thin arrow": <code>X -&gt; substring-after('$') -&gt; number() =&gt; sum()</code>.
          The effect of the thin arrow is that instead of passing the value of the LHS to the function on the RHS
          <i>en bloc</i>, we pass it one item at a time. Of course, if the value on the LHS is a single item, then
          it doesn't matter which kind of arrow we use, both have the same effect.</p>
    <p>If you're a fan of map-reduce terminology, then you'll recognize this instantly as a map-reduce
          pipeline. The <code>-&gt;</code> operations are doing a mapping, and the final <code>=&gt;</code> does a reduce.
            If you're more into functional thinking, you probably think of it more in terms of function composition.</p>
    <p>Of course thin arrows can also be used with arbitrary expressions, just like thick arrows:
          <code>(0 to 3) -&gt; {~ + 1} -&gt; format-integer('a') =&gt; string-join('.')</code> returns 
            <code>"a.b.c.d"</code>.</p>
    <p>And now I'd like to pull one more rabbit out of the hat. What if I want a function that applies the
            above pipeline to any input sequence. I could write <code>function($x){$x -&gt; {~ + 1} -&gt; 
              format-integer('a') =&gt; string-join('.')}</code> but that seems clunky. I'm looking for a nice way
          to supply functions as arguments to higher-order functions like sort, where other languages have
          shown that a concise notation for anonymous functions (like <code>a -&gt; a+1</code> in Javascript) can
          make code a lot simpler, less verbose, more readable.</p>
    <p>So my proposal is this: just remove the left-hand expression, so you have something starting with
          <code>-&gt;</code> or <code>=&gt;</code>, and use this as an anonymous arity-1 function.</p>
    <p>So you can now do: <code>//employee =&gt; sort((), -&gt;{~/@salary})</code> to sort employees
            by salary, or <code>//employee =&gt; sort((), -&gt;{~/@salary}-&gt;substring-after('$')-&gt;number())</code> 
          if you need to do a bit more processing.</p>
    <p>As another little refinement, in the case of <code>-&gt;</code>, the implicit argument is
          always a single item, so we can bind it to the context item. So <code>-&gt;{~/@salary}</code>
          can be simplified to <code>-&gt;{@salary}</code>. Basically, within curly braces on the RHS of <code>-&gt;</code>,
          <code>.</code> and <code>~</code> mean the same thing.</p>
    <p>I believe that all these constructs can be added to the grammar without introducing ambiguity
          or backwards incompatibility, but I haven't proved it conclusively yet.</p>
    <h3>Postscript</h3>
    <p>The <code>~</code> construct seems to be the missing ingredient to enabling pipelines in XSLT.
          Consider:</p>
    <p><pre>
&lt;xsl:pipeline&gt;
  &lt;xsl:apply-templates select="/" mode="m1"/&gt;
  &lt;xsl:apply-templates select="~" mode="m2"/&gt;
  &lt;xsl:for-each select="~"&gt;
    &lt;e&gt;&lt;xsl:copy-of select="."/&gt;&lt;e&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:pipeline&gt;             
            </pre></p>
    <p>Here "~" is acting as an implicit variable to pass the result of one instruction to be the input for
          the next: basically eliminating the clunky <code>xsl:variable</code> declarations needed to do this today.
          The instructions that form the children of the <code>xsl:pipeline</code> element are effectively
          connected to each other with an implicit <code>=&gt;</code> operator.</p>
  </div></content></entry><entry><title>helloWorld.Saxon-JS for Node.js</title><link href="https://blog.saxonica.com/norm/2020/11/15-helloWorldNode.html" rel="alternate" type="text/html"/><id>https://blog.saxonica.com/norm/2020/11/15-helloWorldNode.html</id><published>2020-11-15T17:53:00Z</published><content type="xhtml" xml:base="https://blog.saxonica.com/norm/2020/11/15-helloWorldNode.html"><div xmlns="http://www.w3.org/1999/xhtml">


<p>You may already have seen my
<a href="../10/27-helloWorld.html">helloWorld.Saxon-JS</a> posting. That
was about getting Saxon-JS working in your browser. This post is about
getting Saxon-JS working in Node.js.</p>

<p>I’m still tinkering with some personal projects and I’ve decided
that for one of them, I’m going to experiment with using Node.js. The
app is going to do its thing and then eventually I’m going to want to
build a web page to show the results.</p>

<p>I’m sure there are ways to do this in Node.js, but this is pretty
much the first ever thing I’ve built in node, so I don’t know what
they are. What I do know is that I’ve got a wodge of JSON and I want
to turn it into a web page.</p>

<p>XSLT to the rescue. And XSLT on the server side this time.</p>

<p>As before, I was able to follow <a href="https://www.saxonica.com/saxon-js/documentation/">the
documentation</a> and get it up and running. But once again, it
involved a lot more head scratching (and re-reading the <a href="https://www.saxonica.com/saxon-js/documentation/index.html#!api/transform">SaxonJS.transform
API page</a>) than I would care to admit. This time, I think the main
difficulty was my inexperience with node more than anything else. </p>

<p>What I would have liked <em>this time</em> was a simple Node.js
project that pulled all the pieces together so that I could build it
and see it working, and then begin to hack on it.</p>

<p>So I built one:
<a href="https://github.com/Saxonica/helloWorldNodeJS">https://github.com/Saxonica/helloWorldNodeJS</a>.
</p>

<p>There’s really nothing to show, it’s about getting it to run locally, but I
think the TL;DR is pretty straightforward.</p>

</div></content></entry><entry><title>Draft Proposals for XSLT/XPath/XQuery 4.0</title><link href="https://blog.saxonica.com/mike/2020/11/14-qt40-proposal-comments.html" rel="alternate" type="text/html"/><id>https://blog.saxonica.com/mike/2020/11/14-qt40-proposal-comments.html</id><published>2020-11-14T19:19:00Z</published><content type="xhtml" xml:base="https://blog.saxonica.com/mike/2020/11/14-qt40-proposal-comments.html"><div xmlns="http://www.w3.org/1999/xhtml">

      <h2>Draft Proposals for XSLT/XPath/XQuery 4.0</h2>

    
    <p>I've been working on translating the ideas in my XML Prague 2020 paper, 
      entitled <a href="https://www.saxonica.com/papers/xmlprague-2020mhk.pdf">a Proposal for XSLT 4.0</a> into concrete specifications, and my first attempt at this can be found
    here:</p>
    
    <p>
      I'm hoping to gather together a community group of some kind to take this forward; meanwhile I've published a very preliminary set of drafts:
      </p>
    <ul>
      <li><a href="https://www.saxonica.com/qt4specs/XT/Overview-diff.html">XSLT</a></li>
      <li><a href="https://www.saxonica.com/qt4specs/FO/Overview-diff.html">Functions and Operators</a></li>
      <li><a href="https://www.saxonica.com/qt4specs/XP/xpath-40-diff.html">XPath</a></li>
      <li><a href="https://www.saxonica.com/qt4specs/XQ/xquery-40-diff.html">XQuery</a></li>
      </ul>

    
    <p>I put these ideas up yesterday on the XML community Slack channel and got some great feedback.
    Unfortunately Slack isn't really a good vehicle for managing the response to this feedback. I'm
    going to organise some GitHub space for a more structured discussion, but meanwhile, here
    are my reactions to the initial comments:</p>
    
    <h3>Phil Fearon:</h3>
    <p>There’s a lot to digest here so hope to provide feedback after I’ve read this more thoroughly.
    One suggestion (inspired by ReactJS/JSX) is to provide some syntactical sugar for <code>xsl:call-template</code>. 
    So a call to a named template appears more like a literal result element (perhaps with a special namespace), 
    with attributes that correspond to template params. This could also allow the child items of the special-LRE 
    to be passed to the named template, accessed via a special $children param.
    </p>
    <p><i>Yes, I've been wanting to do something like this for years, and it's really not difficult, so I've
    added it. If EX is listed in <code>extension-element-prefixes</code>, and if there's a named template
      <code>name="ex:action"</code>, then <code>&lt;ex:action a="expr" b="expr"/&gt;</code> is interpreted
    as an <code>xsl:call-template</code> with <code>xsl:wth-param</code> children for parameters <code>a</code> and
    <code>b</code>.</i></p>
    
    <h3>Liam Quin</h3>
    <p>first quick note, best NOT to have them say W3C Recommendation on them as this may cause confusion.</p>
    <p><i>Yes, sorry about that, still working my way around the stylesheets that generate the boilerplate text...</i></p>
    
    <p>2d, cam xsl:text have a select attribute? i don't think value-of can be deprecated :disappointed: 
      but xsl:text select= would be consistent &amp; may help.</p>
    
    <p><i>It's one of these things that one would like to simplify, but we can only add things not remove them,
    so that's not easy.</i></p>
    <p>" the tunnel parameters that are implicitly passed in a template call may have names that duplicate 
      the names of non-tunnel parameters that are explicitly passed on the same call." is a major source 
      of difficult debugging if you forget tunnel=yes. Maybe the answer is just a warning from impl'ns.
    </p>
    
    <p><i>Yes. How to solve this without breaking compatibility? Perhaps a dynamic error if you declare a non-tunnel
    parameter, and at run-time there's a tunnel parameter with that name, but no non-tunnel parameter, or vice versa?
    Or, as you say, just rely on warnings. I agree it's a very common mistake that's hard to debug.</i></p>
    <p>The "at $pos" of XQuery is super useful. position() is tricksy.Maybe for-each at="name" ?</p>
    <p><i>In 3.0 we experimented with replacing some of the context functions with explicit variable bindings
    and it got a bit messy, but I think it's a shame we didn't persevere. The toughest one is <code>last()</code>,
    it would be awfully nice if we knew statically whether <code>last()</code> was going to be needed or not,
    but again, hard to fix without breaking code.</i></p>
    
    <p>prefix binding didn't make the cut for XPath?</p>
    <p><i>I did a design for this and didn't like it enough to put it in. I'll try again.</i></p>
    <p>item-at() seems not much easier than $xxx ! let $p := position() return $yyy[$p]</p>
    <p><i>I'm toying now with an alternative to item-at() that's much more powerful: slice(sequence, positions)
      so you can do <code>slice($s, 5)</code> or <code>slice($s, 5 to 10)</code> or 
      <code>slice($s, -1)</code> or <code>slice($s, 1 by 3 to count($s))</code> or
      <code>slice($s, -2 by -1 to -count($s))</code>. Here <code>A by B to C</code> is an extension
    of the current range expression where <code>A to B</code> means <code>A by 1 to B</code>.</i></p>
    <p>replace-with() seems like perl's e flag (JS has one too) but alas  no polymorphism so can't 
    write replace(., $expr, myfunc#1m 'e')</p>
    However,  what about adding a map or an array of  matching subgroups? ".{$2 || $1 * 2 || $2}"
    <p><i>Yes, I think it's a really useful capability, but I think it's cleaner to make it a separate function.
    Have to think about how subgroups might work.</i></p>
    
    <h3>Reece H. Dunn </h3>
    <p>I like the enum(...) syntax in addition to the union(...) syntax.</p>
    
    
    <p>I like the extension of element and attribute type tests to be full name tests. 
    The ability to define types for path expressions like (ol|ul) is missing, though.</p>
    
    <p><i>Yes, I'm in two minds whether union(X, Y, Z) should be restricted to a union of atomic types,
    or whether it should allow a union of any types including node types. Orthogonality suggests the latter,
    but I was too timid to propose that.</i></p>
    
    
    <p>For named item types, is it possible to make them available as part of the in-scope schema types 
    (renamed to in-scope types that would include the schema and named types?), so you could say 
    person-name instead of item-type(person-name). -- Having to qualify the named item types everywhere 
    could get too verbose, especially if the name is short. _NOTE:_ This is done for MarkLogic types 
    where you can refer to map:map, cts:query, etc.</p>
    
    <p><i>Interesting idea. There's obviously a need to resolve conflicts but that's not a stopper.
    I think I was more concerned with the idea that if it's a QName then it must be atomic, and the
    messy fact that the sets of schema types and item types overlap, and the overlap contains all atomic types
    and some but not all union types.</i></p>
    
    <h3>Liam Quin</h3> 
    <p>hmm, xsl:sequence could do with an "as" attribute.</p>
    <p><i>Not convinced. You start wanting to put it anywhere e.g. on xsl:if or xsl:apply-templates.</i></p>
    
    
    
    <h3>Reece H. Dunn</h3>
    <p>In https://www.saxonica.com/qt4specs/XP/xpath-40-diff.html#id-itemtype-subtype, 
    rule 2(d) is missing the reference to the EnumerationType symbol ("A is an ," instead of "A is an EnumerationType,").</p>
    
    <p><i>Stylesheet trouble. The XSLT and XPath spec stylesheets have diverged, the XSLT spec allows 
      <code>&lt;termref def="some-term"/&gt;</code> and picks up the term from the definition, but 
      the XPath spec requires <code>&lt;termref def="some-term"&gt;term&lt;/termref&gt;</code>. I need to bring them
    back into line. Applies to your subsequent comments also.</i></p>
    
    
    <h3>Martin Honnen</h3>
    <p>I like the separator attribute on xsl:apply-templates and xsl:for-each. 
    I wonder whether it would make sense to add it to xsl:for-each-group as well.</p>
    
    <p><i>Yes. Also xsl:for-each-member. I'm not sure whether it should be an AVT or a general expression:
    with a general expression you could insert <code>br</code> or <code>hr</code> separators, especially if we have element constructor
    functions in XPath (<code>separator="build:element('hr')"</code>)</i> </p>
    
 
    <h3>Liam Quin</h3>  9 hours ago
    <p>i've been wondering abut the possibility of an xsl:uri-resolver for some time. </p>
    <p><i>Not sure what it would do?</i></p>
    <p>Also  about xsl:mode elements being able to contain xsl:template elements.</p>
    <p><i>Yes, I've wanted that for a long time. To be honest, it's not in 3.0 because I couldn't convince Sharon.</i></p>
    
    <h3>Reece H. Dunn</h3> 
    <p>The changes for XPath/XQuery look good. I see you changed the syntax for the context item and lambda syntaxes 
    to a unified syntax. I like that the concise and full syntaxes are now consistent.</p>
    
    
    <p>Given that . is allowed in a ParamList, does that mean I can now define a function that works on the path context item? For example:
    declare function local:f(.) { xs:integer(.) + 2 };
    //values/local:f()</p>
    
    <p><i>Actually, allowing "." here was an oversight caused by my changing the way the grammar rules worked.
    But there might be some benefit it keeping it.</i></p>
    
    <p>... does that mean that the context-dependent functions in F&amp;O should be defined using that syntax. For example:
    fn:data(.) as xs:anyAtomicType*</p>
    
    <p><i>I hadn't thought of baking the "implicit . as parameter" convention into the language, but it might make sense
    if it can be done.</i></p>
    
    <h3>Liam Quin</h3> 
    <p>in XQuery i don't understand "The for evaluation of the function body is absent, 
    unless the signature uses the "." notation, in which case it is evaluated with a singleton 
    focus bound to the supplied argument value."</p>
    <p><i>Markup trouble again.</i></p>
    
 
    <h3>Martin Honnen</h3>  9 hours ago
    <p>If xsl:for-each has a separator attribute, wouldn't xsl:for-each-member benefit from it as well?</p>
    <p><i>Yes, see above.</i></p>
    
    <h3>Reece H. Dunn</h3>  9 hours ago
    <p>For the schema import in XQuery, would it make sense to have:
    [22]    	SchemaPrefix 	   ::=    	("namespace" NCName "=") | ("default" ("element" | "type") "namespace")
    now that the element and type namespaces are separate, similar to how DefaultNamespaceDecl has changed.</p>
    
    <p><i>I thought about this and decided not. If you want finer control, use multiple declarations.</i></p>
    

    <p>For parameter lists and context items, would it be more useful to have the context item as an optional first parameter? That would mirror the proposed variadic argument syntax (defined for arguments at the end of the parameter list), and would allow arguments to be passed to the function, such as:
    declare function local:add(., $n) { xs:integer(.) + $n };
    //values/local:add(2)</p>
    
    <p><i>I quite like that in principle. Needs more thought.</i></p>
    
    Reece H. Dunn  9 hours ago
    <p>Is there any description of the arity of context item based functions? -- There should be a note or something similar to say that the context item for a function definition or inline function expression does not count to its arity, so function () and function (.) both have an arity of 0.
    </p>
    
    <p><i>I was thinking of them simply as arity-1 functions, suitable for callbacks in things like fn:filter and fn:sort.
    You're opening up new possibilities which I need to ponder.</i></p>
    <h3>line0 </h3> 
    <p>Great to see the spec coming to light!</p>
    <p>I proposed to add two new signatures to for-each</p>
    <p>for-each(item()*, function (item(), xs:positiveInteger) as item()*) as item()*</p>
    <p>for-each(item()*, function (item(), xs:positiveInteger, item()*) as item()*) as item()*</p>
    
    <p><i>I've proposed that the function coercion rules should allow you to supply an arity-1 function where
    an arity-2 function appears in the signature; so we can extend fn:for-each to take a <code>function(item, integer)</code>
    as the predicate callback, and you can still supply <code>function(item)</code> if you don't care about the position.</i></p>
    
    <p>which would bring for-each on par with FLOWR expressions ( for window and for … in … at ).</p>
    <p><i>It would be great to see windowing done with higher-order functions, but it's a significant piece of design
    and not my top priority - even though it would bring XSLT up to the level of XQuery for this kind of functionality.</i></p>
    
    
    
    <h3>Martin Honnen </h3> 
    <p>For fn:transform, Saxon has already added the option source-location as that is needed 
    to use fn:transform with streaming; I think it makes sense to integrate that option into the fn:transform specification of the FO 4 draft.
    </p>
    <p><i>Good point.</i></p>
    
  </div></content></entry><entry><title>XSLT Update – Some Ideas</title><link href="https://blog.saxonica.com/mike/2020/10/29-xslt_update_some_ideas.html" rel="alternate" type="text/html"/><id>https://blog.saxonica.com/mike/2020/10/29-xslt_update_some_ideas.html</id><published>2020-10-29T16:19:00Z</published><content type="xhtml" xml:base="https://blog.saxonica.com/mike/2020/10/29-xslt_update_some_ideas.html"><div xmlns="http://www.w3.org/1999/xhtml">
    <h1>XSLT Update – Some Ideas</h1>
    <p>I can't help feeling that many simple transformations on XML documents could be expressed more simply (an idea I explored with the interactive Gizmo tool available in Saxon 10).</p>
    <p>I also think that if we had simpler syntax for simple operations, it might become easier to optimise. In particular, I'd like to be able to do simple operations like adding an attribute to the outermost element of a tree without doing a physical copy of the entire tree.
      (I wrote about that in an <a href="https://www.saxonica.com/papers/xmlprague-2018mhk.pdf">XML Prague paper</a>, but I had to abandon the idea because the code became too complicated. As often happens, the bugbear was namespaces. For example, if you add a namespaced attribute to the outermost element, then the new namespace declaration has to propagate all the way down the tree.)</p>
    <p>I'd also like to see transformations on JSON structures (maps and arrays) become much easier.</p>
    <p>I've prototyped these ideas in the <a href="https://www.saxonica.com/documentation/index.html#!extensions/instructions/deep-update">saxon:deep-update</a>
      and <a href="https://www.saxonica.com/documentation/index.html#!extensions/instructions/update">saxon:update</a> extensions,
      but I don't think these are the last word on the subject. (Please try them and give feedback.)</p>
    <p>A simpler update syntax might also be very useful for updating the HTML page in Saxon-JS.</p>
    <p>I think we can pick up ideas from XQuery Update, but without the complications of pending update lists and in-situ modification.</p>
    <p>Let's start with:</p>
    <pre><code>&lt;xsl:update&gt;
   &lt;xsl:delete match="note"/&gt;
&lt;/xsl:update&gt;
</code></pre>
    <p>The idea is that <code>xsl:update</code> is an instruction that returns a deep copy of the context item (or other selected item if there's a select attribute), applying changes defined by the contained rules. In this case there is one rule, to delete elements that match the pattern note.</p>
    <p>So it's rather like the <code>copy-modify</code> instruction in XQuery; it makes a copy of a supplied tree, with
    defined changes.</p>
    <p>Other rules that might appear within <code>&lt;xsl:update&gt;</code> (for updating XML) might include:</p>
    <pre><code>&lt;xsl:rename match="note" name="comment"/&gt;
&lt;xsl:rename match="a:*" name="{local-name()}"/&gt;
&lt;xsl:replace-value match="@status" value="accepted"/&gt;
&lt;xsl:add-attribute match="proposal(not(@status))" name="status" value="accepted"/&gt;
&lt;xsl:replace-content match="cite[@ref]" select="//bib[@id=current()/@ref]"/&gt;
&lt;xsl:insert match="section(not(head))" position="first"&gt;
   &lt;head&gt;{@title}&lt;/head&gt;
&lt;/xsl:insert&gt;   
</code></pre>
    <p>Hopefully the intent is reasonably intuitive. The idea is to base the primitives on those available in XQuery Update.
    However, I'm not proposing to allow flow-of-control structures such as conditionals and function calls: each invocation
    of <code>xsl:update</code> will simply process the selected tree recursively, applying matching rules to nodes as they
    are found, based on pattern matching.</p>
    <h2>Defining the semantics</h2>
    <p>We can define the semantics of <code>&lt;xsl:update&gt;</code> as being equivalent to <code>&lt;xsl:apply-templates&gt;</code> using a mode that contains a number of implicit template rules, with a default action of <code>shallow-copy</code> (but extended to handle maps and arrays, see below).</p>
    <p>For example, the implicit template rule for the <code>&lt;xsl:rename&gt;</code> rule might be (roughly):</p>
    <pre><code>&lt;xsl:template match="note"&gt;
  &lt;xsl:element name="comment"&gt;
    &lt;xsl:apply-templates select="@*, node()"/&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;
</code></pre>
    <p>Now, what if there's a rule to rename an element and another rule to add an attribute to the same element?</p>
    <p>The way XQuery Update handles that is to process the rules in a number of phases: for example <code>rename</code> operations are handled in phase 1, <code>delete</code> operations in phase 5.</p>
    <p>It's a bit hard to replicate that behaviour using template rules (in fact, this is something users often ask for). We could run a multiphase transformation using multiple modes, but it's not quite the same thing, because the match patterns would apply to the output of the previous phase, not to the original node in the input. And <code>xsl:next-match</code> doesn't do the job either, because we want the effect of the rules to be cumulative.</p>
    <p>We could try another approach, which is to have the template rules return functions, so the <code>&lt;xsl:rename&gt;</code> rule becomes:</p>
    <pre><code>&lt;xsl:template match="note" priority="1"&gt;
  &lt;xsl:sequence select="function($x) {upd:rename($x, 'comment')}"/&gt;
  &lt;xsl:next-match/&gt;  
&lt;/xsl:template&gt;
</code></pre>
    <p>so the effect of <code>apply-templates</code> is to return a sequence of functions (in the order determined by the <code>priority</code> attributes) which are then applied to the node in turn.</p>
    <p>This still doesn't exactly mirror what XQuery Update does, because after processing a node, it's then going to apply the rules to the new content of the node, not to the old content. But perhaps that actually makes more sense?</p>
    <h2>Implementation</h2>
    <p>Part of the aim is not just to have simpler syntax for the user, but also to make the implementation more efficient than the standard transformation approach which always involves physical copying of a tree, no matter how small the changes.</p>
    <p>What I want to achieve is to have a data structure, rather like the HashTrie that we use for representing XDM maps, in which changing one entry doesn't involve copying the whole tree, but at the same time leaves the original value intact. The first essential for such a structure is that it doesn't contain parent pointers: instead upwards navigation is achieved by remembering, when we get to a node, how we got there: this means the same node can be reached by multiple routes, allowing subtrees to be shared between different trees.</p>
    <p>Suppose we are changing the value of a single attribute. It ought to be possible to achieve this by the following steps:</p>
    <ul>
      <li>Find the element we are modifying, remembering the ancestor path of that element.</li>
      <li>Create a "virtual copy" of this element (we already have this capability in Saxon)</li>
      <li>Modify the virtual copy to add the attribute. Only one element is affected; the descendant tree of the virtual copy is shared with the original tree.</li>
      <li>Work back through the ancestors; for each one, create a copy in which the affected child is replaced with the modified child, and all other children are virtual copies of the original.</li>
      <li>Return the copied root node.</li>
    </ul>
    <p>I'm hoping that it will be a lot easier to achieve this with the new syntax than it is with the current processing model, where we have to deal with all kinds of messiness like namespace inheritance. For example, we can define the new syntax so that it's equivalent to <code>inherit-namespaces="no"</code>.</p>
    <h2>What about JSON?</h2>
    <p>I would like this mechanism to work just as well with JSON trees (that is, structures of maps and arrays) as with XML trees.</p>
    <p>We're starting with some advantages: these structures don't have so much baggage. There's no node identity to worry about, no parent navigation, no namespaces. Also, the implementation data structures that we use for maps and arrays already allow efficient constant-time update.</p>
    <p>I've experimented with mechanisms for deep update of a JSON structure with extension functions such as <code>[saxon:pedigree()](https://www.saxonica.com/documentation/index.html#!functions/saxon/with-pedigree)</code>. and <code>saxon:with-pedigree()</code>. That's not exactly usable. But it might be the right primitive to implement something more usable.</p>
    <p>I've also proposed better pattern syntax for maps and arrays. For example, <code>match="tuple(first, last, *)"</code> matches any map that has entries with keys "first" and "last".</p>
    <p>One problem with using the XSLT recursive-descent approach for maps and arrays is that map entries (and indeed array members) aren't actually items. You can match a map as a whole, but it's hard to match one of its entries on its own. Again, I've experimented with various approaches to this. I think the introduction of tuples may help with this: we can define the recursive-descent operation on maps to process (match) each entry in the map in turn, where the entry is presented and matched as a tuple containing key and value. And then we allow syntax such as <code>match="tuple(key: keyPattern, value: valuePattern)"</code> to match these entries.</p>
    <p>But perhaps we don't need to expose this. Perhaps we can define a good enough set of primitive actions that match at the level of the map itself, for example:</p>
    <pre><code>&lt;xsl:remove-entry match="tuple(first, last, *)" key="'salary"/&gt;
&lt;xsl:replace-entry match="tuple(product-code, *) key="'price'" value="?price * 1.05"/&gt;
&lt;xsl:add-entry match="tuple(x, y, *)" key="'area'" value="?x * ?y"/&gt;
</code></pre>
    <p>I think this could fly: but there's a lot of detail to be worked out. Shame we don't have a WG any more to bounce ideas off (and get the bugs out).</p>
  </div></content></entry><entry><title>More Maven experiments</title><link href="https://blog.saxonica.com/norm/2020/10/29-maven.html" rel="alternate" type="text/html"/><id>https://blog.saxonica.com/norm/2020/10/29-maven.html</id><published>2020-10-29T12:12:00Z</published><content type="xhtml" xml:base="https://blog.saxonica.com/norm/2020/10/29-maven.html"><div xmlns="http://www.w3.org/1999/xhtml">


<p>I haven’t actually looked at the server logs to see if anyone else
tried using our experimental Maven repository after
<a href="02-maven.html">I posted</a> about it earlier this month. But
I have, and it’s worked for me!
</p>

<p>I think we’d have to agree that it’s still experimental. After I
put up a raw set of files in a directory structure, a couple of folks
said I should be running a server to do this. I might do that, but I
haven’t had time to try it out yet.</p>

<p>Behind the scenes, I’m also working on build automation.
Ultimately, I want these artifacts to be published automatically.</p>

<p>In the meantime, I’ve added the 9.9.1-8 and 10.3 releases of HE (also
<a href="https://search.maven.org/artifact/net.sf.saxon/Saxon-HE">available</a>
on Maven Central), PE, and EE to our Maven repository.</p>

<p>The experimental Maven repository is at
<a href="https://dev.saxonica.com/maven/">https://dev.saxonica.com/maven/</a>.</p>

<p>If you can try it out and let me know if you have trouble (or if you don’t!),
I’d appreciate it.</p>

</div></content></entry><entry><title>helloWorld.Saxon-JS</title><link href="https://blog.saxonica.com/norm/2020/10/27-helloWorld.html" rel="alternate" type="text/html"/><id>https://blog.saxonica.com/norm/2020/10/27-helloWorld.html</id><published>2020-10-27T12:30:00Z</published><content type="xhtml" xml:base="https://blog.saxonica.com/norm/2020/10/27-helloWorld.html"><div xmlns="http://www.w3.org/1999/xhtml">


<p>What happened was, last Friday I decided to make my first foray
into using <a href="https://www.saxonica.com/saxon-js/">Saxon-JS</a>.
I have in mind a personal project that would use it for rendering and
I wanted to get my feet wet.</p>

<p>I was able to follow <a href="https://www.saxonica.com/saxon-js/documentation/">the
documentation</a> and pretty quickly I had it up and running. But
along the way, I stumbled a couple of times. I didn’t read the documentation
carefully enough in one case and in another, I introduced a typo into a URI.</p>

<p>What I would have liked was a simple project that pulled all the
pieces together, one where I could build it and see it working, and
then begin to hack on it.</p>

<p>Since I didn’t find one of those, I built one:
<a href="https://github.com/Saxonica/helloWorldJS">https://github.com/Saxonica/helloWorldJS</a>.
</p>

<p>On the plus side, this project demonstrates both replacing and
appending to web page content with an XSLT transformation, responding
to user events, and calling external JavaScript libraries.</p>

<p>On possibly the less plus side, I’ve used Gradle to pull all the
pieces together. You might argue that obfuscates things a little bit,
if you aren’t familiar with Gradle, but I wanted to put things in the
context of an actual project build and that’s what I use for builds
these days. PRs for branches that demonstrate Make or Ant or your
build tool of choice are welcome. That’s not meant to be the
interesting part.</p>

<p>There are three branches.</p>

<dl>
<dt><code>main</code></dt>
<dd>This branch is the simplest. The HTML page fires off a Saxon JS stylesheet
that transforms an XML document and updates the page with the result.
</dd>
<dt><code>use-script</code></dt>
<dd>This branch does basically the same thing, but instead of loading the XML
document by making another request to the server, the document is embedded in the
initial HTML document in a <code>script</code> element. It was an experiment I wanted
to try. It avoids a round trip to the server to get the XML document at the cost
of having to extract and parse the document from the HTML.
</dd>
<dt><code>render-commonmark</code></dt>
<dd>The personal project I’m thinking of converting to use Saxon-JS
stores some content in <a href="https://commonmark.org/">CommonMark</a>.
I thought it would be interesting to see if I could call an external JavaScript library
to convert that into HTML and then transform it. Yes, I can.
The JavaScript in <code>src/main/js/start.js</code> is a bit cleaner in this
branch, too.
</dd>
</dl>

<p>All three branches include a button that responds (by running an XSLT template
in the stylesheet) when you click it.</p>

<p>I’ve <a href="https://saxonica.github.io/helloWorldJS/">published</a>
the simplest version online, if you just want to see it in all it’s dull glory.</p>

</div></content></entry><entry><title>Atom feeds</title><link href="https://blog.saxonica.com/norm/2020/10/06-atom.html" rel="alternate" type="text/html"/><id>https://blog.saxonica.com/norm/2020/10/06-atom.html</id><published>2020-10-06T17:24:00Z</published><content type="xhtml" xml:base="https://blog.saxonica.com/norm/2020/10/06-atom.html"><div xmlns="http://www.w3.org/1999/xhtml">


<p>A few days ago, when <a href="01-hello.html">I said</a> that I’d
updated the weblog infrastructure, a couple of folks immediately asked
“where are the feeds?”</p>

<p>Good question. I wondered that myself.</p>

<p>I hadn’t got around to it at first, but I spent a little time today
putting them back where (I think) they were:</p>

<ul>
<li><a href="/mike/atom.xml">Atom feed for Mike’s weblog</a></li>
<li><a href="/oneil/atom.xml">Atom feed for O’Neil’s weblog</a></li>
<li><a href="/norm/atom.xml">Atom feed for this weblog</a></li>
<li><a href="/atom.xml">Aggregate feed for all the weblogs</a></li>
</ul>

<p>If you have trouble, please let me know. “It works for me.”</p>

<p>(The irony that this update won’t turn up in your feed reader is not lost on me.)</p>

</div></content></entry><entry><title>Experimenting with Maven</title><link href="https://blog.saxonica.com/norm/2020/10/02-maven.html" rel="alternate" type="text/html"/><id>https://blog.saxonica.com/norm/2020/10/02-maven.html</id><published>2020-10-02T12:27:00Z</published><content type="xhtml" xml:base="https://blog.saxonica.com/norm/2020/10/02-maven.html"><div xmlns="http://www.w3.org/1999/xhtml">


<p>Do you have
<a href="https://www.saxonica.com/license/license.xml">a license</a>
for Saxon PE or EE? Do you use
<a href="https://en.wikipedia.org/wiki/Apache_Maven">Maven</a>?
Would a Maven repository for Saxon PE or EE
be useful to you? (Saxon HE is already released into
<a href="https://search.maven.org/artifact/net.sf.saxon/Saxon-HE">Maven Central</a>.)</p>

<p>I’ve sometimes thought it would be useful, and I fielded a customer
request for it, so I’ve tried to set it up. It’s a bit experimental at
the moment because I’m not entirely certain that I understand all of
the metadata files that are expected in a Maven repository.</p>

<p>I’ve only packaged up the Java release of Saxon 10.2 for the
moment, but if I can get it usefully configured, I’m happy to try to
make it part of the normal release process. We’re thinking of putting
some of the older releases up as well to simplify regression
testing.</p>

<p>The experimental Maven repository is at
<a href="https://dev.saxonica.com/maven/">https://dev.saxonica.com/maven/</a>.</p>

<p>If you can try it out and let me know if you have trouble (or if you don’t!),
I’d appreciate it.</p>

</div></content></entry><entry><title>Hello, world!</title><link href="https://blog.saxonica.com/norm/2020/10/01-hello.html" rel="alternate" type="text/html"/><id>https://blog.saxonica.com/norm/2020/10/01-hello.html</id><published>2020-10-01T11:10:00Z</published><content type="xhtml" xml:base="https://blog.saxonica.com/norm/2020/10/01-hello.html"><div xmlns="http://www.w3.org/1999/xhtml">
<h1>Hello, world!</h1>

<p>A month to the day since I started working at Saxonica, I’m writing
my first weblog posting. I’ll be perfectly honest, it’s mostly to test
that the (new) weblog infrastructure is working. (I’m the new guy, so
I’m doing a few infrastructure-y things. But I’ve also fixed a couple
of bugs! And I have bigger plans!)</p>

<p>We’ve upgraded some of the servers (By “we” I mean mostly O’Neil.
Thank you O’Neil!) and I’ve moved the weblog out of Movable Type. It’s
now a flat collection of XML files that get published with Saxon. It
may be a little rough around the edges at the moment, but I don’t
think I accidentally lost anything. (We have decided not to republish
the comments from the old weblog.) If you find any broken links or
things that don’t look right, please let me know. The sort of markup you
get out of weblog tools is, uh, interesting.</p>

<p>Behind the scenes, I’m moving our CI/CD infrastructure forward and
I hope to publish an experimental Maven repository for the Saxon EE
product “real soon now.”</p>

<p>I’m not exactly sure how I’ll divide up my writings between this
weblog and <a href="https://so.nwalsh.com/">my personal weblog</a>.
I’ll try to cross-link where it’s appropriate.</p>
</div></content></entry><entry><title>String, CharSequence, IKVM, and .NET</title><link href="https://blog.saxonica.com/mike/2020/07/string-charsequence-ikvm-and-net.html" rel="alternate" type="text/html"/><id>https://blog.saxonica.com/mike/2020/07/string-charsequence-ikvm-and-net.html</id><published>2020-07-20T09:06:54Z</published><content type="xhtml" xml:base="https://blog.saxonica.com/mike/2020/07/string-charsequence-ikvm-and-net.html"><div xmlns="http://www.w3.org/1999/xhtml">
      
      <p>A couple of years ago Jeroen Frijters announced that he would no longer be working
         on new IKVM developments (IKVM is the technology we use to make Saxon, which is written
         in Java, run on .NET). At one level that's not a problem: the tool works brilliantly
         and we can continue to use it. However, it doesn't support .NET Core, and Microsoft
         have announced that .NET 5 will be based on .NET Core, so that creates the risk that
         Saxon on .NET will hit a brick wall.</p>
      <p>Various smart people are working on trying to pick up IKVM where Jeroen left off,
         but I don't particularly want to bet the business on them being successful. Jeroen
         produced brilliant software but he left very little in the way of documentation or
         test material, so it's a hard act to follow.</p>
      <p>Meanwhile Microsoft seem to be back-pedalling on their original promise that .NET
         5 would support Java interoperability. They've never given any indication of how it
         would do so, despite much speculation.</p>
      <p>So we've been looking at alternative ways of taking Saxon on .NET forward into the
         future, and one of those is source code conversion. I've been looking at tools such
         as Tangible, which does a good job to a degree: they don't tackle the difficult parts
         of the problem where Java and C# are most different, but they give a very good insight
         into understanding what the difficult parts of the problem are going to be.</p>
      <p>And one of those difficult parts, which I'm focussing on at the moment, is the <b>CharSequence</b> problem. CharSequence is a Java interface that we use very extensively, and there's
         no equivalent on .NET. Unlike other dependencies on Java classes and interfaces, this
         one is impossible to emulate directly, because java.lang.String implements CharSequence,
         and there's no way we can make System.String on .NET do the same.</p>
      <p>The reason we use CharSequence, as with any interface, is so that we can have multiple
         implementations with different performance characteristics. To take a simple example,
         one of our implementations is CompressedWhitespace. A great deal of the text in an
         XML document is made up of whitespace, which sadly cannot be killed at birth: using
         a customised representation for strings that contain only whitespace gives a significant
         space saving. (And space savings also turn into speed improvements, given that execution
         time these days is dominated by how long it takes to get data in and out of the CPU's
         internal cache).</p>
      <p>Given that CharSequence has no equivalent on .NET, it occurred to me to ask how IKVM
         deals with it. Although Jeroen never wrote much documentaton, he did write a lot of
         blog posts about interesting design problems, and sure enough it seems that he gave
         this a lot of attention back in 2003 (how time flies when you're having fun). I thought
         that he might use an implementation of CharSequence that wraps a System.String, but
         it seems he rejected that approach in favour of a mechanism of what he calls "ghost
         interfaces". There's a lot of detail, but the bottom line seems to be that the code:</p>
      <pre><code>CharSequence seq = "foo";
seq.charAt(1);</code></pre>
      <p>is compiled to .NET as:</p>
      <pre><code>System.Object seq = "foo";
if(seq instanceof System.String)
  ((System.String)seq).charAt(1);
else if(seq instanceof CharSequence)
  ((CharSequence)seq).charAt(1);
else
  throw new IncompatibleClassChangeError()</code></pre>
      <p>That looks pretty horrifying, and I've belatedly realised that it could account for
         a lot of our observations on .NET performance over the years.</p>
      <p>When we first built Saxon on .NET, the performance overhead compared with Java was
         around 30%, which was quite acceptable. In recent years we've seen it getting worse,
         with some workloads showing a 300% slow-down, and despite considerable effort we've
         been at a loss to explain why. Synthetic benchmarks on IKVM continued to show a 30%
         overhead, but for Saxon the figure was far worse. We looked hard without success to
         find a hot-spot, something we were doing that IKVM handled particularly badly, but
         the slow-down seemed to be right across the board. I'm now prepared to conjecture
         that it's all down to our use of CharSequence - because CharSequence.charAt() is something
         we do very extensively, throughout the product.</p>
      <p>When data arrives in Saxon from a SAX parser, the content of text nodes arrives in
         char[] arrays, while the content of attributes arrives in String objects. And we keep
         it that way: in the TinyTree, text nodes are effectively slices of a char[] array,
         and attributes are Strings. All the operations that we perform on text, including
         performance-critical operations such as equality matching, sorting, and string-to-number
         conversion, therefore need to work on either representation, and that's essentially
         why we use CharSequence. In general, we don't want to spend time converting data between
         different representations so we can perform different operations on it. </p>
      <p>(In recent releases, though, we've started using a different representation for operations
         where we need to count Unicode codepoints rather than UTF-16 chars. For regular expressions,
         and some other operations such as translate(), we first convert the string to a UnicodeString,
         which is our own interface that supports direct codepoint addressing, with internal
         implementations using 8, 16, or 32 bits per character depending on the widest character
         present in the string).</p>
      <p>So if CharSequence is a problem, what should we do instead? Is there any other way
         we can implement operations such as collation comparison and string-to-number conversion
         efficiently without first converting the data to a common internal format?</p>
      <p>I think part of the solution might be for these operations to be written to use codepoint
         iterators. Iterating over a string using an IntIterator that delivers codepoints is
         probably just as efficient as using a for-loop with charAt(), and it's possible to
         create an IntIterator over any string representation efficiently (meaning, without
         copying the actual characters).</p>
      <p>This suggests the following broad approach:</p>
      <p>(a) For attributes, continue to use Strings</p>
      <p>(b) For text nodes on the Receiver pipeline and in the TinyTree, use an interface
         similar to CharSequence - let's call it UniString - that allows multiple implementations,
         but that doesn't have the magic property that String can be used directly as an implementation.
         (Instead, there will be an implementation of UniString that wraps a String).</p>
      <p>(c) For operations on strings and string-like values, use a codepoint iterator wherever
         possible.</p>
      <p>This is a gross simplification: we're dealing with half a million lines of code that's
         all concerned with string handling, so the detail is horrendous. But having a simplified
         description of the problem and the solution helps greatly when you're hacking through
         the jungle.</p>
   </div></content></entry><entry><title>The Java class hierarchy for XPath type objects</title><link href="https://blog.saxonica.com/mike/2020/02/the-java-class-hierarchy-for-xpath-type-objects.html" rel="alternate" type="text/html"/><id>https://blog.saxonica.com/mike/2020/02/the-java-class-hierarchy-for-xpath-type-objects.html</id><published>2020-02-10T11:26:47Z</published><content type="xhtml" xml:base="https://blog.saxonica.com/mike/2020/02/the-java-class-hierarchy-for-xpath-type-objects.html"><div xmlns="http://www.w3.org/1999/xhtml">
      
      <p>The set of interfaces and classes used in the Java code to represent XSD and XDM types
         has become something of a nightmare. This article is an attempt to explain it. When
         you don't understand something well, you can often improve your understanding by trying
         to explain it to others, so that's what I shall attempt to do.
         </p>
      <p>
         The first complication is that we have to model schema types and item types, and these
         are overlapping categories.
         </p>
      <p>
         Schema types - types as the term is used in XSD - are either simple types or complex
         types; simple types are either atomic types, union types, or list types. We can forget
         about complex types for the time being as they are relatively unproblematic. 
         </p>
      <p>
         With simple types, we should mention in passing that one of the problems is that while
         processing a schema, we don't always immediately know what the variety of a simple
         type is; if it's derived from a base type and we haven't yet analysed the base type,
         then we park it as a "SimpleTypeDefinition" to be turned into an AtomicType, UnionType,
         or ListType later - which means that all references to the type need to be updated.
         </p>
      <p>
         As well as their use in schema processing, schema types are used as type annotations
         on nodes in XDM, and they also appear in XPath expressions as the target of a "cast"
         or "castable" expression.
         </p>
      <p>
         Item types are purely an XDM concept, and they include atomic types, node types, function
         types, map types, array types. Item types when combined with an occurrence indicator
         form a Sequence type. Sequence types are used in XPath in declaring the types of variables,
         parameters, and function results; they are also used in "instance of" and "treat as"
         expressions.
         </p>
      <p>
         Atomic types are both schema types (more specifically, simple types) and item types.
         Not every schema type is an item type (complex types aren't, list types aren't), and
         not every item type is a schema type (node types and function types aren't). The categories
         overlap, so it's not surprising that the Java class hierarchy is complicated.
         </p>
      <p>
         Union types add another complication. A simple union of atomic types (for example
         the union of xs:date and xs:dateTime) is useful as an item type, for example to define
         the type of a function argument or variable. But XSD union types aren't always simple
         unions of atomic types: they can also include list types, and they can define restrictions
         beyond those present in the member types. So XDM defines the concept of a "pure union
         type", which is a simple union of atomic types; pure union types are the only kind
         that can be used as item types. For convenience it's useful to have a term that embraces
         atomic types and pure union types: the XDM specifications call these "generalized
         atomic types", and in Saxon they are referred to as "plain types". Again, these overlapping
         categories make it very hard to get the Java class hierarchy right.
         </p>
      <p>
         Simple types form a lattice; at the top of this lattice is the most general type "xs:anySimpleType",
         and at the bottom is the "void" type "xs:error" (void because it has no instances).
         These "edge case" types are simple types, but they don't fit cleanly into the classification
         of union types, list types, and atomic types.
         </p>
      <p>
         Item types also overlap with XSLT patterns, and with the node tests used in axis steps.
         Constructs such as element(*) and text() are both node tests (suitable for use in
         patterns and axis steps) and item types. Not every item type is a node test (for example,
         array(*) isn't), and not every node test is an item type (for example, *:local isn't).
         Again, we have two intersecting categories. If we draw the Venn diagram of simple
         types, item types, and node tests, we find that simple tests don't overlap with node
         tests, but all other combinations have an intersection.
         </p>
      <p>
         There's another dimension that we try to capture in the Java class hierarchy: we try
         to distinguish built-in types from user-defined types. There are built-in atomic types
         (xs:integer), built-in list types (xs:NMTOKENS), and built-in union types (xs:numeric);
         and there are also used-defined types in each of the three varieties. Capturing two
         dimensions of classification in a class hierarchy typically introduces multiple inheritance
         and complicates the hierarchy.
         </p>
      <p>
         There's also a lot of complexity concerned with the relationship of schema types to
         other kinds of schema component. Again at this level we try to distinguish used-defined
         schema components (those derived from declarations in an XSD source document) from
         built-in schema components (which include not only simple types, but also complex
         types such as xs:anyType and xs:untyped). We distinguish "schema components" as defined
         in the XSD specification (which include not only schema types, but also element declarations,
         attribute declarations, identity constraints etc) and "schema structures" which are
         essentially constructs in a source XSD document; but looking at the code, nearly everything
         you find in a schema seems to be both a "schema component" and a "schema structure"
         and I'm having trouble seeing exactly what the difference between the two categories
         is.
         </p>
      <p>
         The straw that broke the camel's back and made me examine whether refactoring is needed
         was the introduction of locally-declared union types with the syntax "union(xs:date,
         xs:time)". These are clearly union types, but they aren't built-in, and they don't
         correspond to declarations in any source schema, so they don't fit neatly into the
         existing classification of built-in versus user-defined.
         </p>
      <p>
         We've got an awful lot of multiple inheritance in this hierarchy, and the accepted
         wisdom is that if you've got a lot of multiple inheritance, then you need to do some
         refactoring, and replace some of it with delegation.
         </p>
      <p>
         We've got a model for that in the way we handle XSLT match patterns. Although node-tests
         are a subset of patterns, we don't treat node-tests as a subclass of patterns in the
         Java class hierarchy; rather, the class hierarchy for patterns includes a NodeTestPattern
         which contains a reference to a NodeTest. Similarly, atomic types are a subset of
         schema types, but that doesn't mean they need to implement SchemaType in the Java
         class hierarchy; rather the class hierarchy for SchemaTypes could include an AtomicSchemaType
         which contains a reference to an AtomicType.
         </p>
      <p>
         Let's see what we can do.
         </p>
      <p>
         <b>UPDATE 2020-02-18</b></p>
      <p>Well: I had a good go at refactoring this; but the new scheme was getting just as
         complex as the old, so I decided to revert all the work.
         </p>
      <p>
         I tried to split the classes representing simple types into two: the "compile time"
         information used during XSD schema compilation, and the "executable" types used actively
         for validation. But I ended up with just as many classes (or more), and just as much
         multiple inheritance. I did manage to eliminate the messy process whereby a SimpleTypeDefinition
         is converted to an AtomicType, ListType, or UnionType as soon as we know its variety
         (i.e. when the reference to its base type is resolved -- it can be a forwards reference),
         but I found that doesn't open the door to any wider simplification.
         
         
         
         </p>
   </div></content></entry><entry><title>Java Generics revisited</title><link href="https://blog.saxonica.com/mike/2020/01/java-generics-revisited.html" rel="alternate" type="text/html"/><id>https://blog.saxonica.com/mike/2020/01/java-generics-revisited.html</id><published>2020-01-21T21:14:20Z</published><content type="xhtml" xml:base="https://blog.saxonica.com/mike/2020/01/java-generics-revisited.html"><div xmlns="http://www.w3.org/1999/xhtml">
      
      <p>In Saxon 9.9 we took considerable pains to adopt Java Generics for processing sequences:
         in particular the Sequence and SequenceIterator classes, and all their subclasses,
         became Sequence&lt;? extends Item&gt; and SequenceIterator&lt;? extends Item&gt;.
         </p>
      <p>
         I'm now coming to the conclusion that this was a mistake; or at any rate, that we
         went too far.
         </p>
      <p>
         What exactly are the benefits of using Generics? It's supposed to improve type safety
         and reduce the need for casts which, if applied incorrectly, can trigger run-time
         exceptions. So it's all about detecting more of your errors at compile time.
         </p>
      <p>
         Well, I don't think we've been seeing those benefits. And the main reason for that
         is that in most cases, when we're processing sequences, we don't have any static knowledge
         of the kind of items we are dealing with.
         </p>
      <p>
         Sure, when we process a particular XPath path expression, we know whether it's going
         to deliver nodes or atomic values. But when we write the Java code in Saxon to handle
         path expressions, all we know is that the result will always be a sequence of items.
         </p>
      <p>
         There are some cases where particular kinds of expression only handle nodes, or only
         handle atomic values. For example, the input sequences for a union operator will always
         be sequences of nodes. It would be nice if we didn't have to handle a completely general
         sequence and cast every item to class NodeInfo. But it's an illusion to think we can
         get extra type safety that way. The operands of a union are arbitrary expressions,
         and the iterators returned by the subexpressions are going to be arbitrary iterators;
         there's no way we can translate the type-safety we are implementing at the XPath level
         into type-safe evaluators at the Java level.
         </p>
      <p>
         It's particularly obvious that generics give us no type-safety at the API level. In
         s9api, <b>XPathSelector.evaluate()</b> returns an <b>XdmValue</b>. That's a lot better than the JAXP equivalent which just returns <b>Object</b>, but the programmer still has to do casting to convert the items in the return <b>XdmValue</b> to nodes, string, integers, or whatever. And there's no way we can change that; the
         XPath expression is supplied as a string at run-time, so it's only at run-time that
         we know what type of items it returns. If that's true at the API level, it's equally
         true internally. Any kind of expression can invoke any other kind of expression (that's
         what orthogonality in language design is about), which means that the interfaces between
         an expression and its subexpressions are always going to be general-purpose sequences
         whose item type is known only at execution time.
         </p>
      <p>
         There are a couple of aspects of Java  generics that cause us real pain.
         </p>
      <p>
         
         
         
         <ul>
            <li>The first is the XDM rule that every item is itself a <b>Sequence</b>. So if <b>Sequence</b> is a generic type, parameterized by Item type, and <b>Item</b> is a subclass of <b>Sequence</b>, then <b>Item</b> has to be itself a generic type parameterized by its own type. Rather than <b>Item</b>, it has to be <b>Item&lt;? extends Item&gt;</b>; or perhaps it should be <b>Item&lt;? extends Item&lt;? extends Item&gt;&gt;</b>, and so ad infinitum. And then <b>StringValue</b> extends <b>Item&lt;StringValue&gt; </b>and so on. We found ways around that conundrum, but the complexity is horrendous;
               it certainly doesn't achieve the goal of making it easier to write correct code.</li>
            <li>The second is arrays. Arrays don't play at all well with generics; you can't create
               an array of a generic type, for example. And yet there are lots of places where it's
               useful to use arrays, and some where arrays are the only option. VarArgs functions,
               for example, present their arguments as an array. In some cases we wanted to carry
               on using arrays (rather than lists) for compatibility, in other cases we want to use
               them for convenience or for performance. The natural signature for a function call,
               for example is <b>public Sequence call(Context context, Sequence[] args)</b>. There's no way we can refine this in a way that passes static information about
               the argument types from the caller to the callee, because we're using the same Java
               signature for all XPath functions.</li>
         </ul>
         But having got Generics working, at great effort, in 9.9, should we retain them or
         drop them?
         
         </p>
      <p>
         One reason I'm motivated to drop them is .NET. We have a significant user base on
         .NET, but we have something of a potential crisis looming in terms of ongoing support
         for this platform. Microsoft appear to be basing their future strategy around .NET
         Core, allowing .NET Framework to fade away into the sunset. But the technology we
         use for bridging to .NET, namely IKVM, only supports .NET Framework and not .NET Core;
         and Jeroen Frijters who single-handedly developed IKVM and supported it for umpteen
         years (with no revenue stream to support it) has thrown in the towel and is no longer
         taking it forward. So we're looking at a number of options for a way forward on .NET.
         One of these is source code conversion; and to make source code conversion viable
         without forking the code, we need to minimise our dependencies on Java features that
         don't translate easily to C#. Notable among those features is generics.
         </p>
      <p>
         In the short term, I think I'm going to roll back the use of generics in selected
         areas where they are clearly more trouble than they are worth. That's particularly
         true of <b>Sequence</b> and its subclasses, including <b>Item</b>. For <b>SequenceIterator</b> it's probably worth keeping generics for the time being, but we'll keep that under
         review.
         </p>
   </div></content></entry><entry><title>Alphacodes for Sequence Types</title><link href="https://blog.saxonica.com/mike/2019/10/alphacodes-for-sequence-types.html" rel="alternate" type="text/html"/><id>https://blog.saxonica.com/mike/2019/10/alphacodes-for-sequence-types.html</id><published>2019-10-15T14:06:31Z</published><content type="xhtml" xml:base="https://blog.saxonica.com/mike/2019/10/alphacodes-for-sequence-types.html"><div xmlns="http://www.w3.org/1999/xhtml">
      
      <p>In the next releases of Saxon and Saxon-JS we have devised a compact notation for
         representation of <code><b>SequenceType</b></code> syntax in the exported SEF file. This note is to document this syntax.</p>
      <p>The main aims in devising the syntax were compactness, together with fast generation
         and fast parsing. In addition it has the benefit that some operations are possible
         on the raw lexical form without doing a full parse.</p>
      <p>The syntax actually handles <b>ItemTypes</b> as well as <b>SequenceTypes</b>; and in addition, it can handle the two examples of <b>NodeTests</b> that are not item types, namely<i> *:local</i> and <i>uri:*</i>. It can therefore be used in the SEF wherever a <b>SequenceType</b>, <b>ItemType</b>, or <b>NodeTest</b> is required.</p>
      <p>The first character of an alphacode is the occurrence indicator. This is one of: *
         (zero or more), + (one or more), ? (zero or one), 0 (exactly zero), 1 (exactly one).
         If the first character is not one of these, then "1" is assumed; but the occurrence
         indicator is generally omitted only when representing an item type as distinct from
         a sequence type.</p>
      <p>The occurrence indicator is immediately followed by the "primary alphacode" for the
         item type. These are chosen so that <i>alphacode(T)</i> is a prefix of <i>alphacode(U)</i> if and only if <i>T</i> is a supertype of <i>U</i>. For example, the primary alphacode for <b>xs:integer</b> is "ADI", and the primary alphacode for <b>xs:decima</b>l is "AD", reflecting the fact that <b>xs:integer</b> is a subtype of <b>xs:decimal</b>. The primary alphacodes are as follows:</p>
      <p>"" (zero-length string): item()</p>
      <p>A: xs:anyAtomicType<br/>
         AB: xs:boolean</p>
      <p>AS: xs:string<br/>
         ASN: xs:normalizedString<br/>
         ASNT: xs:token<br/>
         ASNTL: xs:language<br/>
         ASNTM: xs:NMTOKEN<br/>
         ASNTN: xs:Name<br/>
         ASNTNC: xs:NCName<br/>
         ASNTNCI: xs:ID<br/>
         ASNTNCE: xs:ENTITY<br/>
         ASNTNCR: xs:IDREF</p>
      <p>AQ: xs:QName<br/>
         AU: xs:anyURI<br/>
         AA: xs:date<br/>
         AM: xs:dateTime<br/>
         AMP: xs:dateTimeStamp<br/>
         AT: xs:time<br/>
         AR: xs:duration<br/>
         ARD: xs:dayTimeDuration<br/>
         ARY: xs:yearMonthDuration<br/>
         AG: xs:gYear<br/>
         AH: xs:gYearMonth<br/>
         AI: xs:gMonth<br/>
         AJ: xs:gMonthDay<br/>
         AK: xs:gDay</p>
      <p>AD: xs:decimal<br/>
         ADI: xs:integer<br/>
         ADIN: xs:nonPositiveInteger<br/>
         ADINN: xs:negativeInteger<br/>
         ADIP: xs:nonNegativeInteger<br/>
         ADIPP: xs:positiveInteger<br/>
         ADIPL: xs:unsignedLong<br/>
         ADIPLI: xs:unsignedInt<br/>
         ADIPLIS: xs:unsignedShort<br/>
         ADIPLISB: xs:unsignedByte<br/>
         ADIL: xs:long<br/>
         ADILI: xs:int<br/>
         ADILIS: xs:short<br/>
         ADILISB: xs:byte</p>
      <p>AO: xs:double<br/>
         AF: xs:float<br/>
         A2: xs:base64Binary<br/>
         AX: xs:hexBinary<br/>
         AZ: xs:untypedAtomic</p>
      <p>N: node()<br/>
         NE: element(*)<br/>
         NA: attribute(*)<br/>
         NT: text()<br/>
         NC: comment()<br/>
         NP: processing-instruction()<br/>
         ND: document-node()<br/>
         NN: namespace-node()</p>
      <p>F: function(*)<br/>
         FM: map(*)<br/>
         FA: array(*)</p>
      <p>E: xs:error</p>
      <p>X: external (wrapped) object<br/>
         XJ: external Java object<br/>
         XN: external .NET object<br/>
         XS: external Javascript object</p>
      <p>Every item belongs to one or more of these types, and there is always a "most specific"
         type, which is the one that we choose.</p>
      <p>Following the occurrence indicator and primary alphacode are zero or more supplementary
         codes. Each is preceded by a single space, is identified by a single letter, and is
         followed by a parameter value. For example the sequence type "element(BOOK)" is coded
         as "1NE nQ{}BOOK" - here 1 is the occurrence indicator, NE indicates an element node,
         and nQ{}BOOK is the required element name. The identifying letter here is "n". The
         supplementary codes (which may appear in any order) are as follows:</p>
      <p>n - Name, as a URI-qualified name. Used for node names when the primary alphacode
         is one of (NE, NA, NP). Also used for the XSD type name when the type is a user-defined
         atomic or union type: the basic alphacode then represents the lowest common supertype
         that is a built-in type.  (Note: we assume that type names are globally unique. This
         cannot be guaranteed when deploying a SEF file: the schema at the receiving end might
         vary from that of the sender.) Also used for the class name in the case of external
         object types (in this case the namespace part will always be "Q{}"). Note that strictly
         speaking, the forms <i>*:name</i> and <i>name:*</i> can appear in a <b>NameTest</b>, but never in a <b>SequenceType</b>. However, they can be represented in alphacodes using the syntax <b>"n*:name"</b> and <b>"nQ{uri}*"</b> respectively. The syntax <b>"~localname"</b> is used for a name in the XSD namespace. </p>
      <p>c - Node content type (XSD type annotation), as a URI-qualified name optionally followed
         by "?" to indicate nillable. The syntax "~localname" is used for a name in the XSD
         namespace. Optionally present when the basic code is (NE, NA); omitted for NE when
         the content is <b>xs:untyped</b>, and for NA when the content is <b>xs:untypedAtomic</b>. Only relevant for schema-aware code.</p>
      <p>k - Key type, present when the basic code is FM (i.e. for maps), omitted if the key
         type is <b>xs:anyAtomicType</b>. The value is the alphacode of the key type, enclosed in square brackets: it will
         always start with "1A".</p>
      <p>v - Value type, present when when the basic code is (FM, FA) (i.e. for maps and arrays),
         omitted if the value type is <b>item()*</b>. The value is the alphacode of the value type, enclosed in square brackets. For example
         the alphacode for <b>array(xs:string+)* </b>is "*FA v[+AS]".</p>
      <p>r - Return type, always present for functions. The value is the alphacode of the return
         type, enclosed in square brackets.</p>
      <p>a - Argument types, always present for functions. The value is an array of alphacodes,
         enclosed in square brackets and separated by commas. For example, the alphacode for
         the function <b>fn:dateTime#2</b> (with signature <i>($arg1 as xs:date?, $arg2 as xs:time?) as xs:dateTime?)</i> is "1F r[?AM] a[?AA,?AT]"</p>
      <p>m - Member types of an anonymous union type. The value is an array of alphacodes for
         the member types (these will always be atomic types), enclosed in square brackets
         and comma-separated. The basic code in this case will be "A", indicating xs:anyAtomicType.
         This is not used for the built-in union type xs:numeric, nor for user-defined atomic
         types defined in a schema; it is used only for anonymous union types defined using
         the Saxon extension syntax "union(a, b, c)".</p>
      <p>e - Element type of a document-node() type, present optionally when the basic code
         is ND. The value is an alphacode, which will always start with "1NE".</p>
      <p>t - Components of a tuple type (Saxon extension). The value is an array of tokens,
         enclosed in square brackets, where each token comprises the name of the component
         (an NCName), a colon, and the alphacode of the component type.</p>
      <p>i, u, d - Venn type. The item type is the intersection, union, or difference of two
         item types. The letter "i", "u", or "d" indicates intersection, union, or difference
         respectively, followed by a list of (currently always two) item types enclosed in
         square brackets and separated by a comma. The principal type will typically be "N"
         or "NE". Saxon uses venn types internally to give a more precise inferred type for
         expressions; it is probably largely unused at run-time, and can therefore be safely
         ignored when reading a SEF file.</p>
      <p>Named union types have a basic alphacode of "A", followed by the name of the union
         type in the form "A nQ{uri}local". The syntax "~localname" is used for a name in the
         XSD namespace, so the built-in union types xs:numeric and xs:error are represented
         as "A n~numeric" and "A n~error" respectively.</p>
      <p><i>TODO: the documentation for union types is not aligned with the current implementation</i></p>
      <p>Examples:</p>
      <p>0 - empty-sequence()</p>
      <p>1AS - xs:string</p>
      <p>1N - node()</p>
      <p>1 - item()</p>
      <p>* - item()*</p>
      <p>1NE nQ{}item - element(item)</p>
      <p>1ND e[1NE nQ{}item] - document-node(element(item))</p>
      <p>*FM k[1AS] v[?AS] - map(xs:string, xs:string?)*</p>
      <p>1F a[?AS,*AO] r[1AB] - function(xs:string?, xs:double*) as xs:boolean</p>
      <p>Version: 2019-10-30</p>
   </div></content></entry><entry><title>A new push event API</title><link href="https://blog.saxonica.com/mike/2019/05/a-new-push-event-api.html" rel="alternate" type="text/html"/><id>https://blog.saxonica.com/mike/2019/05/a-new-push-event-api.html</id><published>2019-05-01T16:34:00Z</published><content type="xhtml" xml:base="https://blog.saxonica.com/mike/2019/05/a-new-push-event-api.html"><div xmlns="http://www.w3.org/1999/xhtml">
      
      <p>For various internal and performance reasons, we're making some changes to Saxon's
         internal Receiver interface for the next release. This interface is a SAX-like interface
         for sending an XML document (or in general, any XDM instance) from one processing
         component to another, as a sequence of events such as startElement(), attributes(),
         characters(), and so on.
         </p>
      <p>
         The interface is very widely used within Saxon: it handles communication from the
         XML parser to the document builder, document validation, serialization, and much else.
         It also allows instructions to be executed in "push mode", so for example when XSLT
         constructs a result tree, the tree is never actually constructed in memory, but instead
         events representing the tree are sent straight from the transformer to the serializer.<br/>
         I know that although this interface is labelled as internal, some user applications
         attempt either to implement the interface or to act as a client, sending events to
         one of Saxon's many implementations of the interface. So in making changes, it seems
         a good time to recognize that there is a need for an interface at this level, and
         that existing candidates are really rather clumsy to use.
         
         </p>
      <p>
         Among those candidates are the venerable SAX ContentHandler interface, and the newer
         StAX XMLStreamWriter interface.
         </p>
      <p>
         There are a number of structural reasons that make the ContentHandler hard to use:
         </p>
      <p>
         
         
         
         <ul>
            <li>It offers a number of different configuration options for XML parsers, which cause
               namespace information to be provided in different ways. But the ContentHandler has
               no way of discovering which of these options the XML parser (or other originator of
               events) is actually using.</li>
            <li>It's not actually one interface but several: some events are sent not to the ContentHandler,
               but to a LexicalHandler or DTDHandler.</li>
            <li>The information available to the ContentHandler doesn't align well with the information
               defined in the XDM data model; for example, comments are available only to the LexicalHandler,
               not to the ContentHandler</li>
         </ul>
         In addition, the way QNames and namespaces are handled makes life unnecessarily difficult
         for both sides of the interface.
         
         </p>
      <p>
         In some ways the XMLStreamWriter is an improvement, and I've certainly used it in
         preference when writing an application that has to construct XML documents in this
         way. But a major problem of the XMLStreamWriter is that it's underspecified, to the
         extent that there is a separate guidance document from a third-party suggesting how
         implementations should interpret the spec. Again, the main culprit is namespace.
         </p>
      <p>
         One of the practical problems with all these event-based interfaces is that debugging
         can be very difficult. In particular, if you forget to issue an endElement() call,
         you don't find out until the endDocument() event finds there's a missing end tag somewhere,
         and tracking down where the unmatched startElement() is in a complex program can be
         a nightmare. I decided that addressing this problem should be one of the main design
         aims of a new interface -- and it turns out that it isn't difficult.
         </p>
      <p>
         Let's show off the new design with an example. Here is some code from Saxon's InvalidityReportGenerator,
         which generates an XML report of errors found during a schema validation episode,
         using the XMLStreamWriter interface:
         </p>
      <pre><strong>writer</strong>.writeStartElement(<strong>REPORT_NS</strong>, <strong>"meta-data"</strong>);
<strong>writer</strong>.writeStartElement(<strong>REPORT_NS</strong>,<strong>"validator"</strong>);
<strong>writer</strong>.writeAttribute(<strong>"name"</strong>, Version.<em>getProductName</em>() + <strong>"-" </strong>+ getConfiguration().getEditionCode());
<strong>writer</strong>.writeAttribute(<strong>"version"</strong>, Version.<em>getProductVersion</em>());
<strong>writer</strong>.writeEndElement(); //&lt;/validator&gt;
<strong>writer</strong>.writeStartElement(<strong>REPORT_NS</strong>,<strong>"results"</strong>);
<strong>writer</strong>.writeAttribute(<strong>"errors"</strong>, <strong>"" </strong>+ <strong>errorCount</strong>);
<strong>writer</strong>.writeAttribute(<strong>"warnings"</strong>, <strong>"" </strong>+ <strong>warningCount</strong>);
<strong>writer</strong>.writeEndElement(); //&lt;/results&gt;
<strong>writer</strong>.writeStartElement(<strong>REPORT_NS</strong>,<strong>"schema"</strong>);
<strong>if </strong>(<strong>schemaName </strong>!= <strong>null</strong>) {
    <strong>writer</strong>.writeAttribute(<strong>"file"</strong>, <strong>schemaName</strong>);
}
<strong>writer</strong>.writeAttribute(<strong>"xsd-version"</strong>, <strong>xsdversion</strong>);
<strong>writer</strong>.writeEndElement(); //&lt;/schema&gt;
<strong>writer</strong>.writeStartElement(<strong>REPORT_NS</strong>,<strong>"run"</strong>);
<strong>writer</strong>.writeAttribute(<strong>"at"</strong>, DateTimeValue.<em>getCurrentDateTime</em>(<strong>null</strong>).getStringValue());
<strong>writer</strong>.writeEndElement(); //&lt;/run&gt;
<strong>writer</strong>.writeEndElement(); //&lt;/meta-data&gt;</pre>
      <p>And here is the equivalent using the new push API:</p>
      <pre>Push.Element metadata = <strong>report</strong>.element(<strong>"meta-data"</strong>);
metadata.element(<strong>"validator"</strong>)
        .attribute(<strong>"name"</strong>, Version.<em>getProductName</em>() + <strong>"-" </strong>+ getConfiguration().getEditionCode())
        .attribute(<strong>"version"</strong>, Version.<em>getProductVersion</em>());
metadata.element(<strong>"results"</strong>)
        .attribute(<strong>"errors"</strong>, <strong>"" </strong>+ <strong>errorCount</strong>)
        .attribute(<strong>"warnings"</strong>, <strong>"" </strong>+ <strong>warningCount</strong>);
metadata.element(<strong>"schema"</strong>)
        .attribute(<strong>"file"</strong>, <strong>schemaName</strong>)
        .attribute(<strong>"xsd-version"</strong>, <strong>xsdversion</strong>);
metadata.element(<strong>"run"</strong>)
        .attribute(<strong>"at"</strong>, DateTimeValue.<em>getCurrentDateTime</em>(<strong>null</strong>).getStringValue());
metadata.close();</pre>
      <p>What's different?
         The most obvious difference is that the method for creating a new element returns
         an object (a Push.Element) which is used for constructing the attributes and children
         of the element. This gives it an appearance rather like a tree-building API, but this
         is an illusion: the objects created are transient. Methods such as attribute() use
         the "chaining" design - they return the object to which they are applied - making
         it easy to apply further methods to the same object, without the need to bind variables.
         The endElement() calls have disappeared - an element is closed automatically when
         the next child is written to the parent element, which we can do because we know which
         element the child is being attached to.</p>
      <p>There are a few other features of the design worthy of attention:</p>
      <ul>
         <li>Names of elements and attributes can be supplied either as a plain local name, or
            as a QName object. A plain local name is interpreted as being in the default namespace
            in the case of elements (the default namespace can be set at any level), or as being
            in no namespace in the case of attributes. For the vast majority of documents, there
            is never any need to use QNames; very often the only namespace handling is a single
            call on setDefaultNamespace().</li>
         <li>The close() method on elements (which generates the end tag) is optional. If you write
            another child element, the previous child is closed automatically. If you close a
            parent element, any unclosed child element is closed automatically. The specimen code
            above shows one call on close(), which is useful in this case for readability: the
            reader can see that no further children are going to be added.</li>
         <li>The argument of methods such as attribute() and text() that supplies the content may
            always be null. If the content is null, no attribute or text node is written. This
            makes it easier to handle optional content without disrupting the method chaining.</li>
      </ul>
      <p>I have rewritten several classes that construct content using push APIs to use this
         interface, and the resulting readability is very encouraging.</p>
   </div></content></entry><entry><title>Representing namespaces in XDM tree models</title><link href="https://blog.saxonica.com/mike/2019/02/representing-namespaces-in-xdm-tree-models.html" rel="alternate" type="text/html"/><id>https://blog.saxonica.com/mike/2019/02/representing-namespaces-in-xdm-tree-models.html</id><published>2019-02-01T11:59:58Z</published><content type="xhtml" xml:base="https://blog.saxonica.com/mike/2019/02/representing-namespaces-in-xdm-tree-models.html"><div xmlns="http://www.w3.org/1999/xhtml">
      
      <p>Most tree representations of XML, including the Saxon TinyTree and LinkedTree implementation,
         as well as DOM, represent namespace information by holding a set of namespace declarations
         and undeclarations on each element node.
         </p>
      <p>
         I'm considering a change to this representation (for the Saxon implementations) to
         do something that more closely reflects the way namespaces are actually defined in
         XDM: each element node has a set of in-scope namespaces (held in a NamespaceMap object)
         containing all the information about the namespaces that apply to that element.
         </p>
      <p>
         The obvious objection to this, and the reason I've never done it before, is that it
         looks at first sight to be very inefficient. But consider:
         </p>
      <p>
         (a) in the vast majority of documents, there are very few namespace declarations on
         any element other than the root
         </p>
      <p>
         (b) if there are no namespace declarations on an element, it can point to the same
         NamespaceMap object that its parent element points to; in most cases, all elements
         in the document will point to the same shared NamespaceMap.
         </p>
      <p>
         (c) having a NamespaceMap object immediately available on every element node means
         we never need to search up the ancestor axis to resolve namespace prefixes
         </p>
      <p>
         (d) there are still opportunities for implementations of NamespaceMap that use "deltas"
         if space-saving in pathological cases is considered necessary.
         </p>
      <p>
         Note that the NamespaceMap holds prefix=uri pairs, not namespace nodes. Namespace
         nodes have node identity and parentage, which is what makes them so expensive. prefix-uri
         pairs are just pairs of strings without such baggage, and they can be freely shared
         across element nodes.
         </p>
      <p>
         The current implementation I'm using for NamespaceMap is an immutable map implemented
         as a pair of String[] arrays, one for prefixes and one for uris. The prefix array
         is maintained in sorted order so we can use binary search to find a prefix. Insertion
         of a new prefix/uri mapping is O(n), but this doesn't matter because the number of
         bindings is usually less than ten, and it's a rare operation anyway that only happens
         during tree construction.
         </p>
      <p>
         Because the NamespaceMap is immutable, the system is quite easy to implement in a
         tree builder that gets notified of namespaces incrementally (for example by a SAX
         parser). The tree builder maintains a stack of NamespaceMap objects. On a startElement
         event it allocates to the element the same NamespaceMap object that the parent element
         is using; when a namespace declaration or undeclaration is encountered, this is replaced
         with a new NamespaceMap with the required modifications.
         </p>
      <p>
         The real motivation for the change is in implementing copy operations. In complex
         multi-phase transformations both deep and shallow element copy operations are very
         frequent, and copying of the namespace information is a significant cost. The XSLT
         and XQuery language semantics require that when an element is copied, all its in-scope
         namespaces are copied, and this requires searching the ancestor axis to find them
         (we try quite hard to optimize this away, but we're not always successful). If the
         in-scope namespaces are readily to hand in a simple immutable object, we save this
         effort and just pass the complete object down the pipeline.
         </p>
      <p>
         The builder for the tree to which the element is being copied now has to merge this
         set of namespaces with the existing namespaces inherited from ancestor elements on
         the receiving tree. It should now be clear why I chose the particular data structure
         for the NamespaceMap: merging two sets of namespace bindings reduces to merging two
         sorted arrays, which is quite an efficient operation. It's also easy to optimize for
         the common case where the in-scope namespaces of the element being copied are exactly
         the same as the in-scope namespaces of its parent element (typically we'll find that
         the same NamespaceMap object is in use), in which case the merge becomes a null operation.
         </p>
      <p>
         Of course, there are many details to work through (not least, how we fit this in with
         third-party tree models that continue to use declarations and undeclarations). But
         initial experiments are looking encouraging.
         </p>
   </div></content></entry><entry><title>The Receiver Pipeline</title><link href="https://blog.saxonica.com/mike/2018/06/the-receiver-pipeline.html" rel="alternate" type="text/html"/><id>https://blog.saxonica.com/mike/2018/06/the-receiver-pipeline.html</id><published>2018-06-20T11:07:12Z</published><content type="xhtml" xml:base="https://blog.saxonica.com/mike/2018/06/the-receiver-pipeline.html"><div xmlns="http://www.w3.org/1999/xhtml">
      
      <p>A significant feature of the internal architecture of Saxon is the <b style="font-size: 1em;">Receiver</b> pipeline. A receiver is an object that (rather like a SAX ContentHandler) is called
         with a sequence of events such as <i style="font-size: 1em;">startElement()</i>, <i style="font-size: 1em;">characters()</i>, and<i style="font-size: 1em;"> endElement()</i>; it typically does some processing on these events and then calls similar events
         on the next Receiver in the pipeline. The mechanism is efficient, because it avoids
         building a tree in memory, and because it allows much of the conditional logic of
         the processing (for example, whether or not to validate the document) to be executed
         at the time the pipeline is constructed, rather than with conditional code executed
         for every event that occurs.</p>
      <p>Receiver pipelines are used throughout Saxon: from doing whitespace stripping on the
         source document, to serialization of the result tree. The schema validator is implemented
         as a receiver pipeline, as are operations such as namespace fixup.</p>
      <p>But despite the elegance of the design, there have been some perennial problems with
         the implementation. For example, there are variations on exactly what input different
         implementations of Receiver will accept: some for example require an <i>open()</i> event while others don't; some accept entire element or document nodes in an <i>append()</i> event while others don't. This limits the ability to construct a pipeline using arbitrary
         combinations of Receivers, and worse, it's very hard to establish exactly what the
         permitted combinations are.</p>
      <p>This has come to a head recently in trying to get some of the new features in XSLT
         3.0 and XQuery 3.1 working reliably and robustly. The straw that broke the camel's
         back was the innocent-seeming <b>item-separator</b> serialization property. The item-separator is used while doing "sequence normalization"
         as the first stage of serialization; and the problem was that we didn't really do
         sequence normalization as a separate step in the processing. The obvious symptom that
         there are design problems here has been that whenever we get all the XQuery tests
         working, we find we've broken XSLT; and then when we get all the XSLT tests working,
         we find XQuery is now failing.</p>
      <p>The model according to the specs is that the transformation or query engine produces
         "raw" results (which can be any sequence of items), and this is then input to the
         serialization process (or possibly just to sequence normalization, which wraps the
         results in a document node and then delivers the document). But although Saxon could
         deliver raw results from an XQuery running in "pull" mode (the <i>XQueryEvaluator.iterate()</i> method) we never really had the capability to produce raw output in push mode: the
         push code did sequence normalization within the query/transformation logic, rather
         than leaving it to the serializer. That's for historic reasons, of course: with XSLT
         2.0, that's the way it was defined (the result of the transformation was always a
         document, with optional serialization).</p>
      <p>So the first principle to establish in sorting this out is: the interface between
         the query or transformation engine and the Destination (which may or may not be a
         Serializer) is a raw sequence, delivered over the Receiver interface.</p>
      <p>This requires a definition of exactly how a raw sequence is delivered over this interface:
         that is, what's the contract between the provider of the Receiver interface and the
         client (the sender of events). I've created that definition, and I've also written
         a Receiver implementation which validates that the sequence of events conforms to
         this definition; we can put this validation step into the pipeline when we feel it
         useful (for example, when running with assertions enabled). This exercise has revealed
         quite a few anomalies that should be fixed, for example cases where<i> endDocument()</i> is not being called before calling <i>close()</i>.</p>
      <p>There are three ways of delivering output from a query or transformation: raw output,
         document output (the result of sequence normalization), and serialized output. The
         next question that arises is, who decides which form is delivered. The simplest solution
         is: this is decided entirely at the API level, and does not depend on anything in
         the stylesheet or query. (This means that the XSLT build-tree attribute is ignored
         entirely.) In s9api terms, your choice of Destination object determines which kind
         of output you get. And at the implementation level, the Destination object always
         receives raw output; we don't want the transformation engine doing different things
         depending what kind of Destination has been supplied.</p>
      <p>The other related area that needed sorting out was the API interaction with<b> xsl:result-documen</b>t. We've always had the <i>OutputURIResolver</i> as a callback for determining what should happen to secondary result documents, but
         this is no longer fit for purpose. It was already a struggle to extend it to handle
         thread safety when the xsl:result-document instruction became asynchronous; further
         extending it to work with the s9api <i>Destination</i> framework has never been attempted because it just seemed too difficult. Having made
         the decision to introduce a dependency on Java 8 for the next major Saxon release,
         I think we can solve this at the API level with two enhancements:</p>
      <p>
         
         
         <ol>
            <li style="caret-color: black; color: black; font-family: -webkit-standard;">on <i>XsltTransformer</i> and <i>Xslt30Transformer</i>, a new method <i>setResultDocumentResolver()</i> which takes as argument an implementation of <i>Function&lt;URI, Destination&gt;</i> - that is a function that accepts an absolute URI as input, and returns a <i>Destination</i>;</li>
            <li>on <i>Destination</i>, a new method <i>onClose()</i> which takes as argument a <i>Consumer&lt;Destination&gt;</i>.</li>
         </ol>
         </p>
      <p>So when <b>xsl:result-document</b> is called, we construct the absolute URI and pass it to the registered result document
         resolver, and then use the returned <i>Destination</i> to write the result tree. On completion we call any <i>onClose()</i> handler registered with the <i>Destination</i>, which gives the application the opportunity to process the result document (for
         example, by writing it to a database).</p>
      <p>Of course, we have to work out how to implement this while retaining a level of backwards
         compatibility for applications using the existing <i>OutputURIResolver</i>.</p>
      <p>A tricky case with xsl:result-document has been where the href attribute is omitted
         or empty. I think the cleanest design here is to call the registered result document
         resolver passing the base output URI as argument, and use the returned Destination
         in the normal way. The application then has to sort out the fact that the original
         primary Destination for the transformation is not actually used.</p>
      <p>Yet another complication in the design is the rule in XSLT that when <b>xsl:result-document</b> requests schema validation of the output, schema validation is done after sequence
         normalization and before serialization. This is pretty ugly from a specification point
         of view: the serialization spec defines serialization as a 6-step process of which
         sequence normalization is the first; the XSLT spec really has no business inserting
         an additional step in the middle of this process. When the specification is ugly,
         the implementation usually ends up being ugly too, and we have to find some way for
         the transformation engine to inject a validation step into the middle of the pipeline
         implemented by the Destination, which ought by rights to be completely encapsulated.</p>
      <p>Standing back from all this, unlike some refactoring exercises, in this case the basic
         design of the code proved to be sound, but it needed reinforcement to make the implementation
         more robust. It needed a clear definition and enforcement of the contract implied
         by the Receiver interface; it needed a clear separation of concerns between the transformation/query
         engine and the Destination processing; and it needed a clean API to control it all.</p>
   </div></content></entry><entry><title>Navigating XML trees using Java Streams</title><link href="https://blog.saxonica.com/mike/2018/04/navigating-xml-trees-using-java-streams.html" rel="alternate" type="text/html"/><id>https://blog.saxonica.com/mike/2018/04/navigating-xml-trees-using-java-streams.html</id><published>2018-04-13T08:31:44Z</published><content type="xhtml" xml:base="https://blog.saxonica.com/mike/2018/04/navigating-xml-trees-using-java-streams.html"><div xmlns="http://www.w3.org/1999/xhtml">
      
      <p>
         
         
         
         <h2><b>Navigating XML trees using Java Streams</b></h2>
         
         
         </p>
      <p>For the next major Saxon release I am planning an extension to the s9api interface
         to exploit the facilities of Java 8 streams to allow powerful navigation of XDM trees:
         the idea is that navigation should be as easy as using XPath, but without the need
         to drop out of Java into a different programming language. To give a flavour, here
         is how you might select the elements within a document that have @class='hidden':</p>
      <p><code>doc.select(descendant(isElement())</code><br/><code>   .where(attribute("class").eq("hidden")))</code></p>
      <p>We'll see how that works in due course.</p>
      <h2>Why do we need it?</h2>
      <p>The combination of Java and XML is as powerful and ubiquitous today as it as been
         for nearly twenty years.
         Java has moved on considerably (notably, as far as this article is concerned, with
         the Java 8 Streams API),
         and the world of XML processing has also made great strides (we now have XSLT 3.0,
         XPath 3.1, and XQuery 3.1),
         but for some reason the two have not moved together. The bulk of Java programmers
         manipulating XML, if we can
         judge from the questions they ask on forums such as StackOverflow, are still using
         DOM interfaces, perhaps with
         a bit of XPath 1.0 thrown in.</p>
      <p>DOM shows its age. It was originally designed for HTML, with XML added as an afterthought,
         and XML namespaces
         thrown in as a subsequent bolt-on. Its data model predates the XML Infoset and the
         (XPath-2.0-defined) XDM model.
         It was designed as a cross-language API and so the designers deliberately eschewed
         the usual
         Java conventions and interfaces in areas such as the handling of collections and iterators,
         not to mention exceptions.
         It does everything its own way. As a navigational API it carries a lot of baggage
         because the underlying tree is assumed
         to be mutable. Many programmers only discover far too late that it's not even thread-safe
         (even when you confine yourself
         to retrieval-only operations).</p>
      <p>There are better APIs than DOM available (for example JDOM2 and XOM) but they're all
         ten years old and haven't caught up with the times. There's nothing in the Java world
         that compares with Linq for C# users, or ElementTree in Python.</p>
      <p>The alternative of calling out from Java to execute XPath or XQuery expressions has
         its own disadvantages. Any
         crossing of boundaries from one programming language to another involves data conversions
         and a loss of type safety.
         Embedding a sublanguage in the form of character strings within a host language (as
         with SQL and regular expressions)
         means that the host language compiler can't do any static syntax checking or type
         checking of the expressions in the
         sublanguage. Unless users go to some effort to avoid it, it's easy to find that the
         cost of compiling XPath expressions
         is incurred on each execution, rather than being incurred once and amortized. And
         the API for passing context from the
         host language to the sublanguage can be very messy. It doesn't have to be quite as
         messy as the JAXP interface used for
         invoking XPath from Java, but it still has to involve a fair bit of complexity.</p>
      <p>Of course, there's the alternative of not using Java (or other general-purpose programming
         languages) at all: you
         can write the whole application in XSLT or XQuery. Given the capability that XSLT
         3.0 and XQuery 3.1 have acquired, that's
         a real possibility far more often than most users realise. But it remains true that
         if only 10% of your application is
         concerned with processing XML input, and the rest is doing something more interesting,
         then writing the whole application
         in XQuery would probably be a poor choice.</p>
      <p>Other programming languages have developed better APIs. Javascript has JQuery, C#
         programmers have Linq,
         Scala programmers have something very similar, and PHP users have SimpleXML. These
         APIs
         all have the characteristic that they are much more deeply integrated into the host
         language, and in particular they exploit
         the host language primitives for manipulation of sequences through functional programming
         constructs, with a reasonable
         level of type safety given that the actual structure of the XML document is not statically
         known.</p>
      <p>That leads to the question of data binding interfaces: broadly, APIs that exploit
         static knowledge of the schema of the
         source document. Such APIs have their place, but I'm not going to consider them any
         further in this article. In my experience
         they can work well if the XML schema is very simple and very stable. If the schema
         is complex or changing, data binding
         can be a disaster.</p>
      <p>
         
         
         
         
         <section>
            
            
            
            <h2><b>The Java 8 Streams API</b></h2>
            
            
            
            <p>This is not the place for an extended tutorial on the new Streams API introduced in
               Java 8. If you haven't come across
               it, I suggest you find a good tutorial on the web and read it before you go any further.</p>
            
            
            
            <p>Java Streams are quite unrelated to XSLT 3.0 streaming. Well, almost unrelated: they
               share the same high-level objectives
               of processing large collections of data in a declarative way, making maximum use of
               lazy evaluation to reduce memory use,
               and permitting parallel execution. But that's where the similarity ends. Perhaps the
               biggest difference is that Java 8 streams
               are designed to process linear data structures (sequences), whereas XSLT 3.0 streaming
               is designed to process trees.</p>
            
            
            
            <p>But just to summarise:</p>
            
            
            
            <ul>
               <li>Java 8 introduces a new interface, <code>Stream&lt;X&gt;</code>, representing a linear sequence of items of type <code>X</code></li>
               <li>Like iterators, streams are designed to be used once. Unlike iterators, they are manipulated
                  using functional operations,
                  most notably maps and filters, rather than being processed one item at a time. This
                  makes for less error-prone programming,
                  and allows parallel execution.</li>
            </ul>
            
            
            
            <p>The functional nature of the Java 8 Streams API means it has much in common with the
               processing model of XPath. The basic thrust
               of the API design presented in this article is therefore to reproduce the primitives
               of the XPath processing model, re-expressing
               them in terms of the constructs provided by the Java 8 Streams API.</p>
            
            
            
            <p>If the design appears to borrow concepts from other APIs such as LINQ and Scala and
               SimpleXML, that's not actually because I have a deep familiarity
               with those APIs: in fact, I have never used them in anger, and I haven't attempted
               to copy anything across literally. Rather, any similarity is because
               the functional concepts of XPath processing map so cleanly to this approach.</p>
            </section>
         
         
         
         <section>
            
            
            
            <h2>The Basics of the Saxon s9api API</h2>
            
            
            
            <p>The Saxon product primarily exists to enable XSLT, XQuery, XPath, and XML Schema processing.
               Some years ago I decided that the standard
               APIs (JAXP and XQJ) for invoking such functionality were becoming unfit for purpose.
               They had grown haphazardly over the years, the various APIs
               didn't work well together, and they weren't being updated to exploit the newer versions
               of the W3C specifications. Some appalling design mistakes
               had been unleashed on the world, and the strict backwards compatibility policy of
               the JDK meant these could never be corrected. </p>
            
            
            
            <p>To take one horrid example: the
               <code>NamespaceContext</code> interface is used to pass a set of namespace bindings from a Java application to
               an XPath processor. To implement this
               interface, you need to implement three methods, of which the XPath processor will
               only ever use one (<code>getNamespaceURI(prefix)</code>). Yet
               at the same time, there is no way the XPath processor can extract the full set of
               bindings defined in the <code>NamespaceContext</code> and copy them
               into its own data structures.</p>
            
            
            
            <p>So I decided some years ago to introduce a proprietary alternative called <b>s9api</b> into the Saxon product (retaining JAXP support alongside), and it has been a considerable
               success, in that it has withstood the test of time rather well. The changes to XSLT
               transformation in 3.0 were sufficiently radical that I forked the
               <code>XsltTransformer</code> interface to create a 3.0 version, but apart from that it has been largely possible
               to add new features incrementally. That's partly
               because of a slightly less obsessive attitude to backwards compatibility: if I decide
               that something was a bad mistake, I'm prepared to change it.</p>
            
            
            
            <p>Although s9api is primarily about invoking XSLT, XQuery, and XPath processing, it
               does include classes that represent objects in the XDM data model,
               and I will introduce these briefly because the new navigation API relies on these
               objects as its foundation. The table below lists the main classes.</p>
            
            
            
            <table>
               
               
               
               <thead>
                  
                  
                  
                  <tr>
                     
                     
                     
                     <th>Class</th>
                     
                     
                     
                     <th>Description</th>
                     </tr>
                  </thead>
               
               
               
               <tbody>
                  
                  
                  
                  <tr>
                     
                     
                     
                     <td valign="top"><code>XdmValue</code></td>
                     
                     
                     
                     <td>Every value is the XDM model is a sequence of items. The <code>XdmValue</code> class is therefore
                        the top of the class hierarchy. Because it's a sequence, it implements <code>Iterable&lt;XdmItem&gt;</code>,
                        so you can use a Java <code>foreach</code> loop to process the items sequentially. In the latest version
                        I have used Java generics to add a type parameter, so <code>XdmValue&lt;XdmNode&gt;</code> is a sequence
                        of nodes, and <code>XdmValue&lt;XdmAtomicValue&gt;</code> is a sequence of atomic values. As well as
                        an <code>iterator()</code> method, it has an <code>itemAt()</code> method to get the <i>N</i>th item,
                        and a <code>size()</code> method to count the items.
                        Internally an <code>XdmValue</code> might exist as an actual sequence in memory, or as a "promise": sufficient
                        data to enable the items to be materialized when they are needed.</td>
                     </tr>
                  
                  
                  
                  <tr>
                     
                     
                     
                     <td valign="top"><code>XdmItem</code></td>
                     
                     
                     
                     <td>This class represents an Item in the XDM model. As such it is both a component of
                        an <code>XdmValue</code>,
                        and also an <code>XdmValue</code> (of length one) in its own right. It's an abstract class, because every
                        item is actually something more specific (a node, an atomic value, a function). Some
                        of the methods
                        inherited from <code>XdmValue</code> become trivial (for example <code>size()</code> always returns 1).
                        </td>
                     </tr>
                  
                  
                  
                  <tr>
                     
                     
                     
                     <td valign="top"><code>XdmNode</code></td>
                     
                     
                     
                     <td>This is a subclass of <code>XdmItem</code> used to represent nodes. Unlike many models of XML, we don't
                        subclass this for different kinds of node: that's mainly because XDM has deliberately
                        aimed at uniformity,
                        with the same accessors available for all node kinds. Many of the methods on <code>XdmNode</code>, such
                        as <code>getNodeName()</code>, <code>getStringValue()</code>, <code>getTypedValue()</code>, and
                        <code>getNodeKind()</code>, are directly equivalent to accessors defined in the W3C XDM specification.
                        But in addition, <code>XdmNode</code> has a method <code>axisIterator</code> to navigate the tree
                        using any of the XPath axes, the result being returned as an iterator over the selected
                        nodes.</td>
                     </tr>
                  
                  
                  
                  <tr>
                     
                     
                     
                     <td valign="top"><code>XdmAtomicValue</code></td>
                     
                     
                     
                     <td>Another subclass of <code>XdmItem</code>, this is used to represent atomic values in the XDM model.
                        As with <code>XdmNode</code>, we don't define further subclasses for different atomic types. There are convenience
                        methods to convert <code>XdmAtomicValue</code> instances to and from equivalent (or near-equivalent) Java
                        classes such as <code>String</code>, <code>Double</code>, <code>BigInteger</code>, and <code>Date</code>.</td>
                     </tr>
                  
                  
                  
                  <tr>
                     
                     
                     
                     <td valign="top"><code>XdmFunctionItem</code></td>
                     
                     
                     
                     <td>From XPath 3.0, functions are first-class values alongside nodes and atomic values.
                        These are
                        represented in s9api as instances of <code>XdmFunctionItem</code>. Two specific subclasses of function,
                        with their own behaviours, are represented using the subclasses <code>XdmMap</code> and <code>XdmArray</code>.
                        I won't be saying much about these in this article, because I'm primarily concerned
                        with navigating
                        XML trees.</td>
                     </tr>
                  </tbody>
               </table>
            </section>
         
         
         
         <section>
            
            
            <h2>The new API: Steps and Predicates</h2>
            
            
            
            <p>The basic concept behind the new extensions to the s9api
               API is navigation using steps and predicates. I'll introduce
               these concepts briefly in this section, and then go on to
               give a more detailed exposition.</p>
            
            
            
            <p>The class <code>XdmValue&lt;T&gt;</code> acquires a new method:</p>
            
            
            
            <p><code>XdmStream select(Step step)</code></p>
            
            
            
            <p>The <code>Step</code> here is a function that takes an item of class <code>T</code> as its input, and returns a stream of items. If we consider a very simple <code>Step</code>, namely <code>child()</code>, this takes a node as input and returns a stream of nodes
               as its result. We can apply this step to an <code>XdmValue</code> consisting entirely of nodes, and it returns the concatenation of the streams
               of nodes obtained by applying the step to each node in the input value. This operation
               is equivalent to the "!" operator in XPath 3.0, or to the
               <code>flatMap()</code> method in many functional programming languages. It's not quite the same as the familiar
               "/" operator in XPath, because
               it doesn't eliminate duplicates or sort the result into document order. But for most
               purposes it does the same job.</p>
            
            
            
            
            <p>There's a class <code>net.sf.saxon.s9api.streams.Steps</code> containing static methods which provide commonly-used steps such
               as <code>child()</code>. In my examples, I'll assume
               that the Java application has <code>import net.sf.saxon.s9api.streams.Steps.*;</code> in its header, so it can use these fields and methods without further
               qualification.</p>
            
            
            
            
            <p>One of the steps defined by this class is <code>net.sf.saxon.s9api.streams.Steps.child()</code>: this step is a function which, given a node, returns its children. There are
               other similar steps for the other XPath axes. So you can find the children of a node
               <code>N</code> by writing <code>N.select(child())</code>.</p>
            
            
            
            
            <p>Any two steps <code>S</code> and <code>T</code>
               can be combined into a single composite step by writing <code>S.then(T)</code>: for example <code>Step grandchildren = child().then(child())</code> gives you
               a step which can be used in the expression <code>N.select(grandchildren)</code> to select all the grandchildren.</p>
            
            
            
            
            <p>The class <code>Step</code> inherits from the standard Java class <code>Function</code>, so it can be used more generally in any Java context where a
               <code>Function</code> is required.</p>
            
            
            
            
            <p><code>Predicate&lt;T&gt;</code> is a standard Java 8 class: it defines a function that can be applied to an object
               of type <code>T</code> to return
               true or false. The class <code>net.sf.saxon.s9api.streams.Predicates</code> defines some standard predicates that are useful when processing XML. For example
               <code>isElement()</code> gives you a predicate that can be applied to any <code>XdmItem</code> to determine if it is an element node.</p>
            
            
            
            
            <p>Given a <code>Step</code> <code>A</code> and a <code>Predicate</code> <code>P</code>, the expression <code>A.where(P)</code> returns a new
               <code>Step</code> that filters the results of <code>A</code> to include only those items that satisfy the predicate <code>P</code>. So, for example,
               <code>child().where(isElement())</code> is a step that selects the element children of a node, so that <code>N.select(child().where(isElement()))</code>
               selects the element children of <code>N</code>. This is sufficiently common that we provide a shorthand: it can also be written
               
               <code>N.select(child(isElement()))</code>.</p>
            
            
            
            
            <p>The predicate <code>hasLocalName("foo")</code> matches nodes having a local name of "foo": so <code>N.select(child().where(hasLocalName("foo"))</code>
               selects the relevant children. Again this is so common that we provide a shorthand:
               <code>N.select(child("foo"))</code>. There is also a two argument version
               <code>child(ns, "foo")</code> which selects children with a given namespace URI and local name.</p>
            
            
            
            
            <p>Another useful predicate is <code>exists(step)</code> which tests whether the result of applying a given step returns at least one item.
               So, for example
               <code>N.select(child().where(exists(attribute("id"))))</code> returns those children of <code>N</code> that have an attribute named "id".</p>
            
            
            
            
            <p>The result of the <code>select()</code> method is always a stream of items, so you can use methods from the Java Stream class
               such as filter() and flatMap() to process the result. Here are some of the standard
               things you can do
               with a stream of items in Java:</p>
            
            
            
            
            <ul>
               <li>You can get the results as an array: <code>N.select(child()).toArray()</code></li>
               <li>Or as a list: <code>N.select(child()).collect(Collectors.toList())</code></li>
               <li>You can apply a function to each item in the stream: <code>N.select(child()).forEach(System.err::println)</code></li>
               <li>You can get the first item in the stream: <code>N.select(child()).findFirst().get()</code></li>
            </ul>
            
            
            
            
            <p>However, Saxon methods such as <code>select()</code> always return a subclass of <code>Stream</code> called <code>XdmStream</code>, and this offers additional methods. For example:</p>
            
            
            
            
            <ul>
               <li>You can get the results as an <code>XdmValue</code>: <code>N.select(child()).asXdmValue()</code></li>
               <li>A more convenient way to get the results as a Java <code>List</code>: <code>N.select(child()).asList()</code></li>
               <li>If you know that the stream contains a single node (or nothing), you can get this
                  using the methods <code>asNode()</code>
                  or <code>asOptionalNode()</code></li>
               <li>Similarly, if you know that the stream contains a single atomic value (or nothing),
                  you can get this using the methods <code>asAtomic()</code> or <code>asOptionalAtomic()</code></li>
               <li>You can get the last item in the stream: <code>N.select(child("para")).last()</code></li>
            </ul>
            
            
            
            
            <section>
               
               
               
               <h2><b>More about Steps</b></h2>
               
               
               
               <p>The actual definition of the <code>Step</code> class is:</p>
               
               
               
               
               <p><code>public abstract class Step&lt;T extends XdmItem&gt;
                     implements Function&lt;XdmItem, Stream&lt;? extends T&gt;&gt; </code></p>
               
               
               
               
               <p>What that means is that it's a function that any <code>XdmItem</code> as input, and delivers a stream of <code>U</code> items as its result (where <code>U</code> is <code>XdmItem</code>
                  or some possibly-different subclass). (I experimented by also parameterizing the class
                  on the type of items accepted, but that didn't work out well.)</p>
               
               
               
               
               <p>Because the types are defined, Java can make type inferences: for example it knows
                  that <code>N.select(child())</code> will return nodes
                  (because <code>child()</code> is a step that returns nodes).</p>
               
               
               
               
               <p>As a user of this API, you can define your own kinds of <code>Step</code> if you want to: but most of the time you will be able to do everything
                  you need with the standard Steps available from the class <code>net.sf.saxon.s9api.stream.Steps</code>. The standard steps include:</p>
               
               
               
               
               <ul>
                  <li>The axis steps <code>ancestor()</code>, <code>ancestor-or-self()</code>, <code>attribute()</code>, <code>child()</code>,
                     <code>descendant()</code>, <code>descendantOrSelf()</code>, <code>following()</code>, <code>followingSibling()</code>,
                     <code>namespace()</code>, <code>parent()</code>, <code>preceding()</code>, <code>precedingSibling()</code>,
                     <code>self()</code>.</li>
                  <li>For each axis, three filtered versions: for example <code>child("foo")</code> filters the axis to select elements by
                     local name (ignoring the namespace if any); <code>child(ns, local)</code> filters the axis to select elements by
                     namespace URI and local name, and <code>child(predicate)</code> filters the axis using an arbitrary predicate: this is
                     a shorthand for <code>child().where(predicate)</code>.</li>
                  <li>A composite step can be constructed using the method <code>step1.then(step2)</code>. This applies <code>step2</code>
                     to every item in the result of <code>step1</code>, retaining the order of results and flattening them into a single stream.</li>
                  <li>A filtered step can be constructed using the method <code>step1.where(predicate1)</code>. This selects those items in the
                     result of <code>step1</code> for which <code>predicate1</code> returns true.</li>
                  <li>A path with several steps can be constructed using a call such as<code>path(child(isElement()), attribute("id"))</code>. This returns a step whose effect is to return the <code>id</code> attributes of all the children of the target node.</li>
                  <li>If the steps are sufficiently simple, a path can also by written means of a simple
                     micro-syntax similar to XPath abbreviated steps. The previous example could also be
                     written <code>path("*", "@id")</code>. Again, this returns a step that can be used like any other step.
                     (In my own applications, I have found myself using this approach very extensively).</li>
                  <li>The step <code>atomize()</code> extracts the typed values of nodes in the input, following the rules in the XPath
                     specification. The result
                     is a stream of atomic values</li>
                  <li>The step <code>toString()</code> likewise extracts the string values, while <code>toNumber()</code> has the same effect as the
                     XPath <code>number()</code> function</li>
               </ul>
               
               
               
               
               <p>Last but not least, <code>xpath(path)</code> returns a <code>Step</code> that evaluates an XPath expression. For example,
                  <code>doc.select(xpath("//foo"))</code> has the same effect as <code>doc.select(descendant("foo"))</code>. A second argument
                  to the <code>xpath()</code> method may be used to supply a static context for the evaluation. Note that compilation
                  of the XPath expression
                  occurs while the step is being created, not while it is being evaluated; so if you
                  bind the result of <code>xpath("//foo")</code> to
                  a variable, then the expression can be evaluated repeatedly without recompilation.</p>
               </section>
            
            
            
            <section>
               
               
               
               <h2><b>More about Predicates</b></h2>
               
               
               
               <p>The <code>Predicate</code> class is a standard Java 8 interface: it is a function that takes any object as input,
                  and returns a boolean.
                  You can use any predicates you like with this API, but the class <code>net.sf.saxon.s9api.streams.Predicates</code> provides some implementations
                  of <code>Predicate</code> that are particularly useful when navigating XML documents. These include the following:</p>
               
               
               
               
               <ul>
                  <li><code>isElement()</code>, <code>isAttribute()</code>, <code>isText()</code>, <code>isComment()</code>,
                     <code>isDocument()</code>, <code>isProcessingInstruction()</code>, <code>isNamespace()</code> test that the item
                     is a node of a particular kind</li>
                  <li><code>hasName("ns", "local")</code>, <code>hasLocalName("n")</code>, and <code>hasNamespaceUri("ns")</code> make tests
                     against the name of the node</li>
                  <li><code>hasType(t)</code> tests the type of the item: for example <code>hasType(ItemType.DATE)</code> tests for
                     atomic values of type <code>xs:date</code></li>
                  <li><code>exists(step)</code> tests whether the result of applying the given step is a sequence containing at least
                     one item; conversely <code>empty(step)</code> tests whether the result of the step is empty. For example, <code>exists(CHILD)</code>
                     is true for a node that has children.</li>
                  <li><code>some(step, predicate)</code> tests whether at least one item selected by the step satisfies the given predicate.
                     For example,
                     <code>some(CHILD, IS_ELEMENT)</code> tests whether the item is a node with at least one element child. Similarly <code>every(step, predicate)</code>
                     tests whether the predicate is true for every item selected by the step.</li>
                  <li><code>eq(string)</code> tests whether the string value of the item is equal to the given string; while <code>eq(double)</code> does
                     a numeric comparison. A two-argument version <code>eq(step, string)</code> is shorthand for <code>some(step, eq(string))</code>.
                     For example, <code>descendant(eq(attribute("id"), "ABC"))</code> finds all descendant elements
                     having an "id" attribute equal to "ABC".</li>
                  <li>Java provides standard methods for combining predicates using <code>and</code>, <code>or</code>, and <code>not</code>. For example
                     <code>isElement().and(eq("foo"))</code> is a predicate that tests whether an item is an element with string-value "foo".</li>
               </ul>
               </section>
            
            
            
            <section>
               
               
               
               <h2><b>The XdmStream class</b></h2>
               
               
               <p>The fact that all this machinery is built on Java 8 streams and functions is something
                  that many users can safely ignore; they are essential foundations, but they are hidden
                  below the surface. At the same time, a user who understands that steps and predicates
                  are Java Functions, and that the result of the select() method is a Java Stream, can
                  take advantage of this knowledge.
                  
                  
                  </p>
               
               
               <p>
                  
                  
                  One of the key ideas that made this possible was the idea of subclassing <code>Stream</code> with <code>XdmStream</code>. This idea was shamelessly stolen from the open-source <strong>StreamEx</strong> library by Tagir Valeev (though no StreamEx code is actually used). Subclassing <code>Stream</code> enables additional methods to be provided to handle the results of the stream, avoiding
                  the need for clumsy calls on the generic <code>collect()</code> method. Another motivating factor here is to allow for early exit (short-circuit
                  evaluation) when a result can be delivered without reading the whole stream. Saxon
                  handles this by registering <code>onClose()</code> handlers with the stream pipeline, so that when the consumer of the stream calls
                  the <code>XdmStream.close()</code> method, the underlying supplier of data to the stream is notified that no more data
                  is needed.
                  </p>
               
               
               
               <h2><b>Examples</b></h2>
               
               
               
               <p>This section provides some examples extracted from an actual program that uses s9api
                  interfaces and does a
                  mixture of Java navigation and XPath and XQuery processing
                  to extract data from an input document.</p>
               
               
               
               
               <p>First, some very simple examples. Constructs like this are not uncommon:</p>
               
               
               
               <p><code>XdmNode testInput = (XdmNode) xpath.evaluateSingle("test", testCase);</code></p>
               
               
               
               <p>This can be replaced with the much simpler and more efficient:</p>
               
               
               
               <p><code>XdmNode testInput = testCase.selectFirst(child("test"));</code></p>
               
               
               
               <p>Similarly, the slightly more complex expression:</p>
               
               
               
               <p><code>XdmNode principalPackage = (XdmNode) xpath.evaluateSingle("package[@role='principal']",
                     testInput);</code></p>
               
               
               
               <p>becomes:</p>
               
               
               
               <p><code>XdmNode principalPackage = testInput.selectFirst(child("package").where(eq(attribute("role"),
                     "principal"));</code></p>
               
               
               
               
               <p>A more complex example from the same application is this one:</p>
               
               
               
               <p><code>boolean definesError = xpath.evaluate("result//error[starts-with(@code, 'XTSE')]",
                     testCase).size() &gt; 0;
                     </code></p>
               
               
               
               <p>Note here how the processing is split between XPath code and Java code. This is also
                  using an XPath function for which we haven't provided a built-in
                  predicate in s9api. But that's no problem, because we can invoke Java methods as predicates.
                  So this becomes:</p>
               
               
               
               <pre><code>boolean definesError = testCase.selectFirst(child("result"), descendant("error").where(
                     some(attribute("code"), (XdmNode n) -&gt; n.getStringValue().startsWith("XTSE"))) != null;</code></pre>
               
               
               </section>
            
            </section>
         </p>
   </div></content></entry></feed>