<?xml version="1.0" encoding="utf-8"?><html xmlns="http://www.w3.org/1999/xhtml">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
      <title>Saxon-CE is 1.0 today</title>
      <meta name="id" content="192" />
      <meta name="author" content="Michael Kay" />
      <meta name="pubdate" content="2012-06-14T08:55:42" />
      <meta name="basename" content="saxon-ce_is_10_today_1" />
      <meta name="blog-id" content="3" />
   </head>
   <body>
      <h1>Saxon-CE is 1.0 today</h1>
      <p>Today we are finally releasing Saxon-CE 1.0: XSLT 2.0 on the browser. It's been a
         long haul (18 months of prototyping, alpha releases and beta releases) but I think
         it has been well worth it. This product, more than anything else that we've done in
         Saxonica over the years, has the potential to change the rules of the game.
         </p>
      <p>
         Why do I think it's so significant? Well, let's look at what it changes.
         </p>
      <p>
         Firstly, it's XSLT 2.0. XSLT 2.0 is twice the language of XSLT 1.0. It's not just
         a few extra features (grouping, regular expressions, multiple output files, user-defined
         functions). Many stylesheets require only half the code when written in XSLT 2.0,
         and many stylesheets that couldn't be written at all in XSLT 1.0 can easily be written
         using 2.0. So it's an enormous step forward in terms of development and maintenance
         productivity, and it greatly increases the range of applications that can be tacked
         using the language.
         </p>
      <p>
         Next, it's not just XSLT 2.0. It's XSLT with extensions to handle user interaction.
         XSLT 1.0 came out in the days of Web 1.0, when displaying content prettily was the
         summit of most people's ambitions. Today people expect the web to be interactive,
         and Saxon-CE meets that need. Without writing any low-level Javascript, you can write
         declarative applications that respond to user interaction. XSLT used to handle half
         the application - the output but not the input; now it handles the whole lot. OK,
         there's a large community out there that has become comfortable with writing Javascript.
         But it's messy, it's hard to debug, it requires a great deal of specialist skill,
         and we think that there's a better and easier way of doing it.
         </p>
      <p>
         And it's cross-browser. There are five major browsers today, and it runs on all of
         them, doing a very good job of masking their differences. That means you're no longer
         constrained to move forward at the pace of the slowest browser vendor. It's no secret
         that some of the browser vendors have lost some of their early enthusiasm for XML.
         It's been a chicken-and-egg problem; users weren't rushing into client-side XSLT without
         universal browser support, and browser vendors weren't rushing into providing that
         support without mass-market adoption. Instead the browser vendors have been competing
         to produce the world's fastest Javascript engine, and we've been able to capitalise
         on that, because internally, Saxon-CE uses that engine.
         </p>
      <p>
         It's also a solid piece of engineering. Saxonica hired Phil Fearon as lead developer
         to take the product through from its initial prototype to the stage it has reached
         now, and he has done a great job. He's made full use of his previous experience developing
         client-side XML editing tools. Under the surface, the product is now rich in diagnostic
         and tracing features that integrate solidly with the console and logging facilities
         in the different browser platforms, providing a solid working environment for the
         professional web developer; it's also got the APIs to enable integration into IDEs,
         which is something we hope we'll see a lot of over the next year or so. Phil has reworked
         the event handling and the exploitation of the Javascript concurrency model to ensure
         that applications are as responsive as possible. We've also had great feedback from
         the user community during beta testing, and we've implemented many ideas that emerged
         from this feedback: to take one simple example, the ability to launch Saxon from the
         xml-stylesheet processing instruction via an XSLT 1.0 bootstrap stylesheet came from
         a chance remark during the XML Prague conference, but it will make a big difference
         to anyone trying to migrate an existing XSLT 1.0 application. 
         </p>
      <p>
         <i>So, it's got a great deal to offer. But, some might ask, isn't it ten years too late?</i>
         </p>
      <p>
         There are two aspects to that question: an engineering aspect, and a fashion aspect.
         To succeed in this world, you need to get the engineering right, but you also need
         to ride the fashion wave. They are not unrelated, but they're not 100% correlated
         either.
         </p>
      <p>
         There's no doubt that XML is less fashionable than it was. That's probably a good
         thing: people are now using XML where it is the right tool for the job, whereas ten
         years ago a lot of people were using XML for jobs that it was never designed for.
         Make no mistake, there is an awful lot of XML around, and that isn't going to change.
         What we hope will change is that more of that XML finds its way onto the browser now
         that there are decent tools for processing it there. The arguments for shipping XML
         to the client and processing it locally haven't changed; the reason it didn't happen
         in the past wasn't that it was a bad idea, it was because the technology wasn't viable
         to make it happen.
         </p>
      <p>
         A lot of the reason that JSON is now preferred for many simple data interchange tasks
         is that when you are using conventional programming languages like Javascript (and
         Java, and C#, and Python, etc), JSON is much easier than XML to manipulate. Programming
         is easier when you use a programming language that matches the data model. So if you're
         using Javascript, JSON is easier than XML; conversely, if you're using XML, you want
         a programming language (XSLT) that is designed for the job. There is absolutely no
         doubt that processing XML in Javascript is a pig, so we think that exactly the same
         pressures that led to people saying "use JSON rather than XML if you can" will lead
         people to say "use XSLT rather than Javascript if you can". Both are ways of solving
         the famous "impedance mismatch" - the reams of code that you need to write when your
         programming language doesn't match your data model. If your data is simple enough
         to represent in JSON, then fine, use it. But a lot of "big data" isn't, so XML is
         here to stay.
         </p>
      <p>
         That's the engineering argument, but can we make it fashionable? Who knows. I think
         that will depend on the user community: it takes a few inspired users to do something
         cool with it, and others will join the bandwaggon. It's not the technology itself
         that inspires the masses, it's what gets built on top of it. We've no shortage of
         ideas as to what could be done (I would love to write a MusicXML application...) but
         we can't do it all ourselves, and we wouldn't want to.
         </p>
      <p>
         So, Saxon-CE 1.0 is here. XSLT 2.0 has finally arrived on the browser, in a very solid
         implementation. Over to you.
         
         
         
         </p>
   </body>
</html>